MODULE Utils;

REQUIRE System;

// --------------------------------------------- Стандартные группы --------------------------------- //

GROUP print 'Печатные формы' : public;

// ---------------------------------- Чтение списка файлов по пути ---------------------------------- //
fileName 'Список файлов' = DATA LOCAL VARISTRING[255] (INTEGER);
fileIsDirectory 'Является директорией' = DATA LOCAL BOOLEAN (INTEGER);
//ftp://username:password@host:port/path or file://path
listFiles 'Получить список файлов' = ACTION CUSTOM 'lsfusion.erp.utils.utils.ListFilesActionProperty' (VARISTRING[255]); 
prevCountFiles = DATA INTEGER ();

resultCustomFile = DATA LOCAL CUSTOMFILE ();
//value, charset, extension
stringToCustomFile 'Запись строки в файл' = ACTION CUSTOM 'lsfusion.erp.utils.utils.StringToFileActionProperty' (VARISTRING[255], VARSTRING[10], VARSTRING[10]);
// --------------------------------------------- Работа со строками --------------------------------- //

lower (TEXT p1) = FORMULA 'lower($1)';

stringEqualsAll(STRING[3] string) = string == STRING[3]('Все');

isWordInCSV = FORMULA NULL INTEGER PG 'CASE WHEN CAST($1 AS text)=ANY(string_to_array($2,\',\')) THEN 1 ELSE NULL END', MS 'CASE WHEN CHARINDEX(\' \' + CAST($1 AS nvarchar(max)) + \' \',\' \' + REPLACE($2,\',\',\' \') + \' \') > 0 THEN 1 ELSE NULL END';

getWord (TEXT p1, TEXT p2, INTEGER p3) = FORMULA '(string_to_array($1,$2))[($3)]';
wordCount (TEXT p1, TEXT p2) = FORMULA 'array_length((string_to_array($1,$2)),1)';

istartsWith = FORMULA NULL INTEGER PG 'CASE WHEN (($1) ILIKE (($2)||\'%\')) THEN 1 ELSE NULL END', MS 'CASE WHEN (($1) LIKE (($2)+\'%\')) THEN 1 ELSE NULL END';
startsWith = FORMULA NULL INTEGER PG 'CASE WHEN (($1) LIKE (($2)||\'%\')) THEN 1 ELSE NULL END', MS 'CASE WHEN (($1) LIKE (($2)+\'%\')) THEN 1 ELSE NULL END';
endsWith = FORMULA NULL INTEGER PG 'CASE WHEN (($1) LIKE (\'%\'||($2))) THEN 1 ELSE NULL END', MS 'CASE WHEN (($1) LIKE (\'%\'+($2))) THEN 1 ELSE NULL END';

// todo : для MS SQL пофиксить формулу, чтобы правильно работало, если в подстроке есть %
isISubstring = FORMULA NULL INTEGER PG 'CASE WHEN position(lower($2) in lower($1)) > 0 THEN 1 ELSE NULL END', MS 'CASE WHEN (($1) LIKE (\'%\'+($2)+\'%\')) THEN 1 ELSE NULL END'; 
isSubstring = FORMULA NULL INTEGER PG 'CASE WHEN position(($2) in ($1)) > 0 THEN 1 ELSE NULL END', MS 'CASE WHEN (($1) LIKE (\'%\'+($2)+\'%\')) THEN 1 ELSE NULL END';

replace (TEXT p1, TEXT p2, TEXT p3) = FORMULA TEXT 'replace($1,$2,$3)';

charLength (TEXT p1) = FORMULA INTEGER PG 'char_length($1)', MS 'len($1)';

substr (TEXT p1, INTEGER p2, INTEGER p3) = FORMULA TEXT 'substring($1, $2, $3)';
substrFrom (TEXT p1, INTEGER p2) = FORMULA TEXT PG 'substring($1, $2)', MS 'substring($1, $2, len($1) - $2 + 1)'; 

ltrim (TEXT p1) = FORMULA TEXT 'ltrim($1)';
rtrim (TEXT p1) = FORMULA TEXT 'rtrim($1)';

ltrim (TEXT p1, TEXT p2) = FORMULA TEXT PG 'ltrim($1,$2)';
rtrim (TEXT p1, TEXT p2) = FORMULA TEXT PG 'rtrim($1,$2)';

trim (TEXT p1) = FORMULA TEXT PG 'trim($1)', MS 'ltrim(rtrim($1))';

left (TEXT p1, INTEGER p2) = FORMULA TEXT 'left($1,$2)';
right (TEXT p1, INTEGER p2) = FORMULA TEXT 'right($1,$2)';

lpad (TEXT p1, INTEGER p2, TEXT p3) = FORMULA TEXT PG 'lpad($1,$2,$3)';
rpad (TEXT p1, INTEGER p2, TEXT p3) = FORMULA TEXT PG 'rpad($1,$2,$3)';

repeat (TEXT p1, INTEGER p2) = FORMULA TEXT PG 'repeat($1,$2)', MS 'REPLICATE ($1,$2)';

onlyDigits (TEXT p1) = FORMULA NULL INTEGER PG 'CASE WHEN trim($1) ~ \'^[0-9]*$\' THEN 1 ELSE NULL END', MS 'CASE WHEN ltrim($1) NOT LIKE \'%[^0-9]%\' THEN 1 ELSE NULL END';

// --------------------------------------------- Работа с числами --------------------------------- //

floor = FORMULA 'floor($1)';
ceil = FORMULA 'ceiling($1)';
ceil = FORMULA 'ceiling(($1)/($2))*($2)';
min = FORMULA '($1+$2-ABS($1-$2))/2';
max = FORMULA '($1+$2+ABS($1-$2))/2';

sqr = FORMULA '($1)*($1)';
sqrt = FORMULA 'sqrt($1)';
percent = FORMULA '(($1)*($2)/100)';
share = FORMULA '(($1)*100/($2))';
round = FORMULA PG 'round(CAST(($1) as numeric),$2)', MS 'round(CAST(($1) as numeric(38,19)),$2)';
abs = FORMULA 'abs($1)';
delta = FORMULA 'abs(($1)-($2))';

ln = FORMULA 'ln($1)';
exp = FORMULA 'exp($1)';

divideInteger(a,b) = INTEGER(a) / INTEGER(b);
divideIntegerNeg = FORMULA INTEGER 'CASE WHEN CAST(($1) AS integer)<0 THEN -CAST(((-CAST(($1) as integer)-1)/CAST(($2) as integer)) as integer) ELSE CAST(CAST(($1) as integer)/CAST(($2) as integer) as integer) END';
divideIntegerRnd = FORMULA INTEGER 'CAST(round(($1)/($2),0) as integer)';

mod = FORMULA 'mod($1,$2)';

iterate(INTEGER i, INTEGER from, INTEGER to) = RECURSION i==from AND from IS INTEGER AND to IS INTEGER STEP i==$i+1 AND i<=to CYCLES IMPOSSIBLE;
count(INTEGER i, INTEGER count) = iterate(i, 1, count);

toInteger (i) = FORMULA INTEGER PG 'convert_to_integer($1)', MS 'dbo.convert_to_integer($1)';
toNumeric (i) = FORMULA NUMERIC[38,19] PG 'convert_to_integer($1)', MS 'dbo.convert_to_integer($1)';

// --------------------------------------------- Округления --------------------------------- //
roundM1 (number) = round(number, -1);
round0 (number) = round(number, 0);
round1 (number) = round(number, 1);
round2 (number) = round(number, 2);
round3 (number) = round(number, 3);
round6 (number) = round(number, 6);

// -------------------------------------------- Свойства под файлы ---------------------------- //

customFile = DATA LOCAL CUSTOMFILE ();
wordFile = DATA LOCAL WORDFILE ();
imageFile = DATA LOCAL IMAGEFILE ();
pdfFile = DATA LOCAL PDFFILE ();
excelFile = DATA LOCAL EXCELFILE();

// --------------------------------------------- Yes/No --------------------------------- //
CLASS YesNo 'Логическое' {
    yes 'ДА',
    no 'НЕТ'
};

META defineHistorizableYesNo(property, defaultProperty, caption, object1, object1Identity, object2, object2Identity, group)
    @defineHistorizableCustomDefault(property, defaultProperty, caption, YesNo, staticCaption,
        object1, object1Identity, object2, object2Identity, 7, group);
END

META defineHistorizableYesNo(property, defaultProperty, caption, object1, object1Identity, object2, object2Identity, object3, object3Identity, group)
    @defineHistorizableCustomDefault(property, defaultProperty, caption, YesNo, staticCaption,
        object1, object1Identity, object2, object2Identity, object3, object3Identity, 7, group);
END

// --------------------------------------------- Диалоги --------------------------------- //

FORM dialogString 'Выбор строку'
    OBJECTS s = VARSTRING[200] FIXED PANEL
    PROPERTIES(s) objValue = OBJVALUE
;

DESIGN dialogString {
    NEW string BEFORE functions.box {
        fill = 1;
        MOVE PROPERTY (objValue) {
            fill = 1;
            caption = 'Введите строку';
            font = 'bold 64';
            panelCaptionAbove = TRUE;
        }
    }
}

FORM dialogDate 'Выбор даты'
    OBJECTS d = DATE FIXED PANEL
    PROPERTIES(d) objValue = OBJVALUE
;

DESIGN dialogDate {
    NEW date BEFORE functions.box {
        fill = 1;
        MOVE PROPERTY (objValue) {
            fill = 1;
            caption = 'Введите дату';
            font = 'bold 64';
            panelCaptionAbove = TRUE;
        }
    }

}

FORM dialogInteger 'Выбор числа'
    OBJECTS i = INTEGER FIXED PANEL
    PROPERTIES(i) objValue = OBJVALUE
;

DESIGN dialogInteger {
    PROPERTY (objValue) {
        caption = 'Введите число';
        font = 'bold 64';
        panelCaptionAbove = TRUE;
    }
}

FORM dialogNumeric 'Выбор числа'
    OBJECTS n = NUMERIC[20,7] FIXED PANEL
    PROPERTIES(n) objValue = OBJVALUE
;

DESIGN dialogNumeric {
    PROPERTY (objValue) {
        caption = 'Введите число';
        font = 'bold 64';
        panelCaptionAbove = TRUE;
    }
}

// --------------------------------------------- Печать --------------------------------- //

FORM printBlankPagePortrait;

FORM printBlankPageLandscape;

// --------------------------- Агрегации --------------------------------- //

// -- Агрегации для 1го объекта -- //

META defineAggregationCustom1 (primProperty, primObject, primClass, aggrObject, aggrClass, aggrProperty)
    aggrObject (primObject) =
        GROUP AGGR aggrClass aggrObject BY primObject(aggrObject)
        WHERE aggrObject IS aggrClass PERSISTENT INDEXED;

    aggrProperty(primClass primObject) => aggrObject(primObject) RESOLVE LEFT;

    is(aggrClass aggrObject) = aggrObject IS aggrClass;
    is(aggrClass aggrObject) => aggrProperty(primObject(aggrObject)) RESOLVE RIGHT;
END

META defineAggregationCustom (primProperty, primObject, aggrObject, aggrProperty)
    @defineAggregationCustom1(primProperty, primObject, ###primObject, aggrObject, ###aggrObject, aggrProperty);
END

META defineAggregationClass (primObject, primClass, aggrObject, aggrClass, aggrProperty)
    primObject = DATA primClass (aggrClass) INDEXED;

    @defineAggregationCustom1(primObject###aggrObject, primObject, primClass, aggrObject, aggrClass, aggrProperty);
END

META defineAggregation (primObject, aggrObject, aggrProperty)
    @defineAggregationClass(primObject, ###primObject, aggrObject, ###aggrObject, aggrProperty);
END

// -- Агрегации для 2х объектов -- //

META defineAggregationCustom (prim1Property, prim2Property, prim1Object, prim1Class, prim2Object, prim2Class, aggrObject, aggrClass, aggrProperty)
    aggrObject (prim1Object, prim2Object) =
        GROUP AGGR aggrClass aggrObject BY prim1Object(aggrObject), prim2Object(aggrObject)
        WHERE aggrObject IS aggrClass;

    aggrProperty(prim1Class prim1Object, prim2Class prim2Object) => aggrObject(prim1Object, prim2Object) RESOLVE LEFT;

    is(aggrClass aggrObject) = aggrObject IS aggrClass;
    is(aggrClass aggrObject) => aggrProperty(prim1Object(aggrObject), prim2Object(aggrObject)) RESOLVE RIGHT;
END

META defineAggregationCustom (prim1Property, prim2Property, prim1Object, prim2Object, aggrObject, aggrProperty)
    @defineAggregationCustom(prim1Property, prim2Property, prim1Object, ###prim1Object, prim2Object, ###prim2Object, aggrObject, ###aggrObject, aggrProperty);
END

META defineAggregationClass (prim1Object, prim1Class, prim2Object, prim2Class, aggrObject, aggrClass, aggrProperty)
    prim1Object = DATA prim1Class (aggrClass) INDEXED;
    prim2Object = DATA prim2Class (aggrClass) INDEXED;

    @defineAggregationCustom(prim1Object###aggrObject, prim2Object###aggrObject, prim1Object, prim1Class, prim2Object, prim2Class, aggrObject, aggrClass, aggrProperty);
END

META defineAggregation (prim1Object, prim2Object, aggrObject, aggrProperty)
    @defineAggregationClass(prim1Object, ###prim1Object, prim2Object, ###prim2Object, aggrObject, ###aggrObject, aggrProperty);
END

// -- Агрегации для 3х объектов -- //

META defineAggregationCustom (prim1Property, prim2Property, prim3Property, prim1Object, prim1Class, prim2Object, prim2Class, prim3Object, prim3Class, aggrObject, aggrClass, aggrProperty)
    aggrClass (prim1Object, prim2Object, prim3Object) =
        GROUP AGGR aggrClass aggrObject BY prim1Object(aggrObject), prim2Object(aggrObject), prim3Object(aggrObject)
        WHERE aggrObject IS aggrClass PERSISTENT INDEXED;

    aggrProperty(prim1Class prim1Object, prim2Class prim2Object, prim3Class prim3Object) => aggrClass(prim1Object, prim2Object, prim3Object) RESOLVE LEFT;

    is(aggrClass aggrObject) = aggrObject IS aggrClass;
    is(aggrClass aggrObject) => aggrProperty(prim1Object(aggrObject), prim2Object(aggrObject), prim3Object(aggrObject)) RESOLVE RIGHT;
END

META defineAggregationCustom (prim1Property, prim2Property, prim3Property, prim1Object, prim2Object, prim3Object, aggrObject, aggrProperty)
    @defineAggregationCustom(prim1Property, prim2Property, prim3Property, prim1Object, ###prim1Object, prim2Object, ###prim2Object, prim3Object, ###prim3Object, aggrObject, ###aggrObject, aggrProperty);
END

META defineAggregationClass (prim1Object, prim1Class, prim2Object, prim2Class, prim3Object, prim3Class, aggrObject, aggrClass, aggrProperty)
    prim1Object = DATA prim1Class (aggrClass);
    prim2Object = DATA prim2Class (aggrClass);
    prim3Object = DATA prim3Class (aggrClass);

    @defineAggregationCustom(prim1Object###aggrObject, prim2Object###aggrObject, prim3Object###aggrObject, prim1Object, prim1Class, prim2Object, prim2Class, prim3Object, prim3Class, aggrObject, aggrClass, aggrProperty);
END

META defineAggregation (prim1Object, prim2Object, prim3Object, aggrObject, aggrProperty)
    @defineAggregationClass(prim1Object, ###prim1Object, prim2Object, ###prim2Object, prim3Object, ###prim3Object, aggrObject, ###aggrObject, aggrProperty);
END

// -- Агрегации для 4х объектов -- //   
META defineAggregationCustom (prim1Property, prim2Property, prim3Property, prim4Property, prim1Object, prim1Class, prim2Object, prim2Class, prim3Object, prim3Class, prim4Object, prim4Class, aggrObject, aggrClass, aggrProperty)
    aggrObject (prim1Object, prim2Object, prim3Object, prim4Object) =
        GROUP AGGR aggrClass aggrObject BY prim1Object(aggrObject), prim2Object(aggrObject), prim3Object(aggrObject), prim4Object(aggrObject) 
        WHERE aggrObject IS aggrClass;// PERSISTENT INDEXED;

    aggrProperty(prim1Class prim1Object, prim2Class prim2Object, prim3Class prim3Object, prim4Class prim4Object) => aggrObject(prim1Object, prim2Object, prim3Object, prim4Object) RESOLVE LEFT;

    is(aggrClass aggrObject) = aggrObject IS aggrClass;
    is(aggrClass aggrObject) => aggrProperty(prim1Object(aggrObject), prim2Object(aggrObject), prim3Object(aggrObject), prim4Object(aggrObject)) RESOLVE RIGHT;
END

META defineAggregationCustom (prim1Property, prim2Property, prim3Property, prim4Property, prim1Object, prim2Object, prim3Object, prim4Object, aggrObject, aggrProperty)
    @defineAggregationCustom(prim1Property, prim2Property, prim3Property, prim4Property, prim1Object, ###prim1Object, prim2Object, ###prim2Object, prim3Object, ###prim3Object, prim4Object, ###prim4Object, aggrObject, ###aggrObject, aggrProperty);
END

META defineAggregationClass (prim1Object, prim1Class, prim2Object, prim2Class, prim3Object, prim3Class, prim4Object, prim4Class, aggrObject, aggrClass, aggrProperty)
    prim1Object = DATA prim1Class (aggrClass) INDEXED;
    prim2Object = DATA prim2Class (aggrClass);
    prim3Object = DATA prim3Class (aggrClass);
    INDEX prim2Object(aggrClass o), prim3Object(o), prim4Object(o);
    prim4Object = DATA prim4Class (aggrClass);
    INDEX prim4Object(aggrClass o), prim2Object(o);

    @defineAggregationCustom(prim1Object###aggrObject, prim2Object###aggrObject, prim3Object###aggrObject, prim4Object###aggrObject, prim1Object, prim1Class, prim2Object, prim2Class, prim3Object, prim3Class, prim4Object, prim4Class, aggrObject, aggrClass, aggrProperty);
END

META defineAggregation (prim1Object, prim2Object, prim3Object, prim4Object, aggrObject, aggrProperty)
    @defineAggregationClass(prim1Object, ###prim1Object, prim2Object, ###prim2Object, prim3Object, ###prim3Object, prim4Object, ###prim4Object, aggrObject, ###aggrObject, aggrProperty);
END

// --------------------------- Групповая корректировка на форме --------------------------------- //

isEditable 'Включить корректировку на форме' = DATA LOCAL NESTED BOOLEAN();

isReadonly = NOT isEditable();

META extendFormEditable (form)
    EXTEND FORM form
        PROPERTIES() isEditable
    ;
    DESIGN form {
        functions.box {
            MOVE PROPERTY(isEditable()) BEFORE rightControls;
        }
    }
END
