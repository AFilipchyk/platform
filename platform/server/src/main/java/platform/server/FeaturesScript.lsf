//////////////// MODULE HEADER //////////////////
// Syntax:
// MODULE moduleName;
// [REQUIRE moduleName1, ..., moduleNameN;]
// [PRIORITY namespace1, ..., namespaceK;]
// [NAMESPACE namespaceName;]

MODULE Features;

REQUIRE System;

/////////// GROUP STATEMENT ////////////

// Syntax:
// GROUP name ['caption'] [: parentGroup];
GROUP base 'Основная группа' : baseGroup;
GROUP simpleGroup;
GROUP sampleGroup : System.baseGroup; // явная квалификация имен

/////////// CLASS STATEMENT ////////////

// Non-static class
// Syntax:
// CLASS [ABSTRACT] name ['caption'] [: nonStaticBaseClass1 [, nonStaticBaseClass2, ..., nonStaticBaseClassN]];
CLASS ABSTRACT namedClass : named;
CLASS emptyClass;
CLASS article 'Товар' : namedClass;
CLASS store 'Склад' : namedClass;
CLASS ABSTRACT document 'Документ' : transaction;
CLASS incomeDocument 'Приход' : document, emptyClass;
CLASS outcomeDocument 'Расход' : document, emptyClass;

// Static class
// Syntax:
// CLASS STATIC name ['caption'] {
//      instanceName1 ['instanceCaption1']
//      [, instanceName2 ['instanceCaption2']]
//      ...
//      [, instanceNameN ['instanceCaptionN']]
// }
// [: nonStaticBaseClass1 [, nonStaticBaseClass2, ..., nonStaticBaseClassN];]
CLASS STATIC storeSize 'Размер склада'
{
    huge 'огромный',
    big 'большой',
    medium 'средний',
    small 'маленький'
}


//////////// PROPERTY STATEMENT///////////
// Common syntax:
// name ['caption'] [(namedParam1, ..., namedParamN)] = propertyExpression [IN group] [PERSISTENT] [TABLE <table name>] [TOOLBAR | (SHORTCUT [propertyExpression] [DEFAULT])]
//                                                                                                 [FIXEDCHARWIDTH <int value>] [MINCHARWIDTH <int value>] [MAXCHARWIDTH <int value>] [PREFCHARWIDTH <int value>]
//                                                                                                 [IMAGE 'name'] [EDITKEY '<key code>' [SHOW | HIDE]] [AUTOSET] [CONFIRM]
//                                                                                                 [REGEXP '<expression>' ['<regExp message>']] [LOGGABLE] [ECHO] [INDEXED]
//                                                                                                 [AGGPROP] [NOT NULL [DELETE [SESSION]]];
// Если именованные параметры не указываются, то они выводятся из propertyExpression
// Специальные имена свойств: PREV, CHANGED, ASSIGNED

// Data property
// Expression syntax:
// [SESSION] DATA returnClass ( [paramClass1, ..., paramClassN] )
// If SESSION modifier is spesified, than session data property will be created.
// Built-in types: INTEGER, LONG, DOUBLE, BOOLEAN, DATE, DATETIME, TEXT, STRING, ISTRING, TIME, WORDFILE, IMAGEFILE, PDFFILE, CUSTOMFILE, EXCELFILE, NUMERIC, COLOR
store(document) = DATA store (document) IN base;
quantity(document, article) = DATA DOUBLE (document, article) IN base;
storeSize(store) = DATA storeSize (store) IN base;

sessionObj() = SESSION DATA object ();

// Join property
// Expression syntax:
// (name | '[' propertyDefinition ']') (param1, ..., paramN)
storeName 'Склад' (document) = name(store(document)) IN base;
storeSizeName = name(storeSize(store)) IN base; // можем не указывать именованные параметры слева от '=', но все равно пользоваться ими
objectIsStore = [IS store](object);             // аналог: object IS store

// IS, AS
// Expression syntax:
// propertyExpression (AS | IS) className
// IS - is(), AS - object()
isIncomeDocument(document) = document IS incomeDocument;


// AND, IF (идентичны по действию)
// Expression syntax:
// propertyExpression (AND | IF) [NOT] propertyExpression
inQuantity(document, article) = quantity(document, article) IF isIncomeDocument(document);
outQuantity(document, article) = quantity($1, $2) IF $1 IS outcomeDocument;  // указание номеров параметров вместо имен

// Group property
// SUM, MAX, MIN, EQUAL group property
// Expression syntax:
// GROUP (SUM | MAX | MIN | EQUAL) propertyExpression [BY propertyExpression1, ..., propertyExpressionN]
incomeQuantity(store, article) = GROUP SUM inQuantity(document, article) BY store(document), article;
outcomeQuantity(store, article) = GROUP SUM outQuantity(doc, art) BY store(doc), art;

incomeQuantity2(store, article) = GROUP SUM quantity(document, article) IF document IS incomeDocument BY store(document), article;
outcomeQuantity2(store, article) = GROUP SUM quantity(doc, art) IF doc IS outcomeDocument BY store(doc), art;

// CONCAT group property
// GROUP CONCAT propertyExpr, separatorPropertyExpr [BY propertyExpr1, ..., propertyExprN] [ORDER [DESC] orderPropertyExpr1, ..., orderPropertyExprK]
allNames() = GROUP CONCAT name(obj) IF obj IS named, ', ' ORDER DESC name(obj);

// UNIQUE group property
// GROUP UNIQUE propertyExpression [BY propertyExpression1, ..., propertyExpressionN] [WHERE propertyExpression]
nameToCountry(name) = GROUP UNIQUE country BY name(country);


// Union property
// Expression syntax:
// UNION (SUM | MAX | OVERRIDE | XOR | EXCLUSIVE) propertyExpression1, ..., propertyExpressionN
testUnion(store, article) = UNION SUM incomeQuantity(store, article), outcomeQuantity(store, article);

// OR property
// Expression syntax:
// propertyExpression1 OR propertyExpression2
// identical to UNION OVERRIDE

// Recursive property
// Expression syntax:
// RECURSION initPropertyExpression STEP stepPropertyExpression [CYCLES [IMPOSSIBLE]]
// Previous value syntax: $param

// IF THEN ELSE property
// Expression syntax:
// IF propertyExpression0 THEN propertyExpression1 ELSE propertyExpression2
documentTypeString 'Тип документа' (doc) = IF (doc IS incomeDocument) THEN ('Приход' IF doc IS incomeDocument) ELSE ('Расход' IF doc IS outcomeDocument);

// Case property
// Expression syntax:
// CASE
//      WHEN whenPropertyExpression1 THEN thenPropertyExpression1
//      ...
//      WHEN whenPropertyExpressionN THEN thenPropertyExpressionN
//      DEFAULT defaultPropertyExpression
// END
storeSizeCode 'Размер склада (код)' (s) = CASE
                                              WHEN storeSize(s) == storeSize.huge THEN ('HUGE' IF s IS store)
                                              WHEN storeSize(s) == storeSize.big THEN ('BIG' IF s IS store)
                                              WHEN storeSize(s) == storeSize.medium THEN ('MEDIUM' IF s IS store)
                                              WHEN storeSize(s) == storeSize.small THEN ('SMALL' IF s IS store)
                                              DEFAULT 'UNKNOWN' IF s IS store
                                          END;

// Partition property
// SUM, PREV partition property
// Expression syntax:
// PARTITION (SUM | PREV) propertyExpression
// [BY propertyExpressionM1, ..., propertyExpressionMN]
// [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
// [WINDOW EXCEPTLAST]
testPartition(store, article) = PARTITION SUM incomeQuantity(store, article) BY store ORDER DESC name(article);

// UNGROUP PROPORTION partition property
// PARTITION UNGROUP propertyObject PROPORTION [STRICT] ROUND(precision) proportionPropertyExpression
// [BY propertyExpressionM1, ..., propertyExpressionMN]
// [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
testAmount(store) = 20.0 IF store IS store;
testData(article) = DATA DOUBLE (article);
testPropPartition(store, article) = PARTITION UNGROUP testAmount PROPORTION STRICT ROUND(2) testData(article) BY store ORDER name(article);

// UNGROUP LIMIT partition property
// PARTITION UNGROUP propertyObject LIMIT [STRICT] limitPropertyExpression
// [BY propertyExpressionM1, ..., propertyExpressionMN]
// [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
testLimitPartition(store, article) = PARTITION UNGROUP testAmount LIMIT STRICT testData(article) BY store ORDER DESC name(article);


// Concatenation/Deconcatenation property
// Expression syntax:
// LIST(propertyExpression1[, ..., propertyExpressionN])
// Access expression syntax with one-base indices:
// concatenatePropertyExpression[2]
ioQuantity(store, article) = LIST(incomeQuantity(store, article), outcomeQuantity(store, article));
onlyIncomeQuantity(store, article) = ioQuantity(store, article)[1];

// Abstract property
// Expression syntax:
// ABSTRACT returnClass ( [paramClass1, ..., paramClassN] )
testAbstract(named) = ABSTRACT INTEGER (namedClass);
// overriding abstract property syntax:
// propertyName [(namedParam1, ..., namedParamN)] += expression;
testAbstract += 5 AND named IS article;
testAbstract(named) += 6 AND named IS store;

// Formula property
// Expression syntax:
// FORMULA [primitiveType] 'formula text $1 + $2'
sum12 = FORMULA DOUBLE '($1)+($2)*2';
testFormula(store, article) = sum12(incomeQuantity(store, article), outcomeQuantity(store, article));

// Computational expressions
// Priority:
// OR
// AND  IF
// ==  !=
// <  >  <=  >=
// (+) (-)
// +  -
// *  /
// - (unary)
//
// Instances: 5, 5L, 6.35, TRUE, 'some string', staticClass.object, 2011_10_25, NULL, #ff0000, RGB(255, 0, 0)
balanceQuantity(store, article) = incomeQuantity(store, article) - outcomeQuantity(store, article);

foo(store, article) = 5 * incomeQuantity($1, $2) - outcomeQuantity($1, $2);
foo2(store, article) = - outcomeQuantity(store, article) + 5 * incomeQuantity(store, article);
bar = incomeQuantity(store, article) * 5 - 3 - 4 + outcomeQuantity(store, article);
bar2(store, article) = 3.5 * incomeQuantity($1, $2) - (5 + outcomeQuantity($1, $2));
foobar(store, article) = [x*x + y](foo(store, article), bar(store, article));   // lambda-like syntax
baz(store, article) = bar(store, article) > bar2(store, article) IN base;
baz2 = foo(s, a) >= 15 == foo2(s, a) >= 15;

storeIsHuge(store) = storeSize(store) == storeSize.huge;                        // static class instance
storeIsHuge2(store) = (storeSize(store) == storeSize.huge) == TRUE;

documentBalance(document, article) = balanceQuantity(store(document), article);

////////////////ACTION PROPERTIES////////////////
// General Syntax:
// ACTION [(param1, ..., paramN)] actionStatement

// List action
// statement syntax:
// [NEWSESSION [AUTOAPPLY]]  {
//      actionStatement1 | LOCAL name = returnClass ( [paramClass1, ..., paramClassK1] )
//      ...
//      actionStatementN | LOCAL name = returnClass ( [paramClass1, ..., paramClassKN] );
// }
//
// If NEWSESSION is specified than action will be performed in new session.
// If AUTOAPPLY is specified - this new session will be applied by default,
// if not - one should do 'EXEC apply();' explicitly.

// Exec action
// statement syntax:
// EXEC actionPropertyName(propertyExpr1, ..., propertyExprN)
// or
// EXEC [actionPropertyExpr](propertyExpr1, ..., propertyExprN)

// Set action
// statement syntax:
// SET propertyExpressionTo <- propertyExpressionFrom [WHERE conditionalExpression]

// If action
// statement syntax:
// IF propertyExpresson
//      THEN actionStatement1
//     [ELSE actionStatement2]

// For/While action
// statement syntax:
// (FOR | WHILE) propertyExpression [ORDER [DESC] orderExpression1, ..., orderExpressionN] DO actionStatement

// Form action
// statement syntax:
// FORM formName
// [OBJECTS object1 [=mappingExpr1], ..., objectN [=mappinExprN] ]
// [INIT propertyExpr1, ..., propertyExprM]
// [CLASS className]
// [NEWSESSION] [MODAL] [CHECK]


// Add object action
// statement syntax:
// ADDOBJ className

// Custom action
// statement syntax:
// CUSTOM 'javaClassName'

// Message action
// statement syntax:
// MESSAGE propertyExpr [ LENGTH n ]
// Default length = 2000

// Change class action
// statement syntax:
// CHANGECLASS object TO className
// built-in or abstract class names are forbidden

// File open/load action
// statement syntax:
// [OPENFILE | LOADFILE] propertyExpression

// Email action
// statement syntax:
// EMAIL
//  [FROM propertyExpression]
//  SUBJECT propertyExpression
//  (TO || CC || BCC) propertyExpression [ (TO || CC || BCC) propertyExpression ...]
//  [(INLINE formName OBJECTS obj1=propertyExpression1, ..., objN=propertyExpressionN) ...]
//  [(ATTACH (PDF, DOCX, HTML, RTF) [NAME propertyExpression] formName OBJECTS obj1=propertyExpression1, ..., objN=propertyExpressionN) ...]

// Confirm action
// statement syntax:
// CONFIRM propertyExpression [LENGTH intValue]

// Request action
// statement syntax:
// REQUEST type (INPUT | [objectName] actionStatement)
// type can be built-in type or OBJECT


copyStoreNameToArticles 'Скопировать имя склада в имена артиклей' (s) = ACTION(s) {
    SET (name(a) AND a IS article) <- (name(s) AND s IS store);
};

copyStoreNameToArticle 'Добавить имя склада к имени артикля' (s, a) = ACTION(s, a) NEWSESSION AUTOAPPLY {
    SET name(a) <- [FORMULA STRING[20] '$1 || $2'](name(a), name(s));
};

copyStoreNameToArticleError 'Скопировать имя склада в имя артикля (с ошибкой)' (s, a) = ACTION(s, a) NEWSESSION {
    SET name(a) <- name(s);
    EXEC apply();
};

createNewStore 'Добавить большой склад' = ACTION () {
    ADDOBJ store;

    SET sessionObj() <- addedObject();

    SET name(k) IF k == sessionObj() <- [FORMULA STRING[20] '$1 || CAST($2 as char(20))']('New store ', sessionObj());
    SET storeSize(k) IF k == sessionObj() <- storeSize.big;
} TOOLBAR IMAGE 'add.png';

///////////////CONSTRAINT STATEMENT//////////////
// Syntax:
// CONSTRAINT propertyExpression [CHECKED [BY propertyName1, ..., propertyNameN]] propertyExpression MESSAGE 'message';
CONSTRAINT foo(store, article) > 1000 CHECKED MESSAGE 'ошибка: >1000';


////////////////FOLLOWS STATEMENT////////////////
// Syntax:
// propertyName(param1, ..., paramN) =>
//      propertyExpression1 [RESOLVE (TRUE | FALSE | ALL | NOTHING) [SESSION]],
//      ...
//      propertyExpressionK [RESOLVE (TRUE | FALSE | ALL | NOTHING) [SESSION]];
//foo(store, article) => foo2(store, article) RESOLVE NOTHING;


////////////////WRITEWHEN STATEMENT//////////////
// Syntax:
// propertyName(param1, ..., paramN) <- valuePropertyExpression WHEN changePropertyExpression;

// inQuantity(document, article) <- 15 WHEN CHANGED(foo(store(document), article));


///////////////////EVENT STATEMENT//////////////
// Syntax:
// WHEN expression DO action [ORDER [DESC] expr1, ..., exprN] [SESSION];

constraintAction (store, article) = ACTION (store, article) {
//    EXEC cancel();
    IF foo(store, article) > 300000 THEN {
        MESSAGE name(article);
    }
};

WHEN foo(store,article)>10000 DO EXEC constraintAction(store, article) ORDER name(article) SESSION;

///////////////////ASPECT STATEMENT//////////////
// Syntax:
// BEFORE | AFTER propertyName(param1, ..., paramN) DO action;

BEFORE constraintAction(store, article) DO MESSAGE 'Before Aspect';

//////////////// FORM STATEMENT /////////////////
// Syntax:
// FORM name ['caption'] [PRINT] [DOCKING | MODAL | FULLSCREEN] | EXTEND FORM name
// [(GroupObjects list | TreeGroupObjects list | Properties list | Filters list | Hints list | OrderBy list | filterGroup | dialog form | edit form | list form)]
// ...
// [(GroupObjects list | TreeGroupObjects list | Properties list | Filters list | Hints list | OrderBy list | filterGroup | dialog form | edit form | list form)];
FORM documentArticle 'По документам'

// GroupObjects list syntax:
// OBJECTS [alias=] className ['<caption>'] | [groupAlias=] ([alias1=] className1 ['<caption1>'], ..., [aliasN=] classNameN ['<captionN>']) [REPORTFILE prop(p1, ..., pK)] [INIT | FIXED] [PANEL | HIDE | GRID] [PAGESIZE <int value>],
//         ...
//         [alias=] className ['<caption>'] | [groupAlias=] ([alias1=] className1 ['<caption1>'], ..., [aliasN=] classNameN ['<captionN>']) [REPORTFILE prop(p1, ..., pK)] [INIT | FIXED] [PANEL | HIDE | GRID] [PAGESIZE <int value>]
OBJECTS document, article

// TreeGroup list syntax:
// TREE [SID] [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] ([alias1=] className1 ['<caption1>'], ..., [aliasN=] classNameN ['<captionN>']) [PARENT <properties separated with space>],
//            ...
//            [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] ([alias1=] className1 ['<caption1>'], ..., [aliasN=] classNameN ['<captionN>']) [PARENT <properties separated with space>]

// Property list syntax:
// PROPERTIES [commonOptions] [alias1=]propName1(param1, ..., paramN1) [options1], ..., [aliasK=]propNameK(param1, ..., paramNK) [optionsK]
// or
// PROPERTIES(param1, ..., paramN) [commonOptions] [alias1=]propName1 [options1], ..., [aliasK=]propNameK [optionsK]
// Special properties: SELECTION, OBJVALUE, ADDOBJ, ADDFORM, ADDSESSIONFORM, EDITFORM, EDITSESSIONFORM
// Property option:    [READONLY] [EDITABLE] [SELECTOR] [HINTNOUPDATE] [HINTTABLE] [COLUMNS (<groupObject list>)] [SHOWIF <mappedProperty>] [BACKGROUND <mappedProperty>]
//                     [HEADER <mappedProperty>] [FOOTER <mappedProperty>] [READONLYIF <mappedProperty>] [FORCE PANEL | HIDE | GRID] [TODRAW <groupObject>]
//                     [FOREGROUND <mappedProperty>]

PROPERTIES store(document), name(article), storeName(document), documentTypeString(document)
PROPERTIES quantity(document, article)
PROPERTIES inQuantity(document, article), outQuantity(document, article), documentBalance(document, article)
PROPERTIES ADDOBJ(document), ADDOBJ(article)

// Filters list syntax:
// FILTERS propertyExpression1, ..., propertyExpressionK
FILTERS name(article);

// Hints list syntax:
// HINTNOUPDATE | HINTTABLE propertyName1, ..., propertyNameN



showForm(document) = ACTION FORM documentArticle OBJECTS document NEWSESSION MODAL;

showDocumentArticleModalForm 'Показать форму "По документам"' = ACTION() NEWSESSION {
    ADDOBJ article;

    FOR (k == addedObject()) DO {
        SET name(k) <- 'this is new article';
        BREAK;
    } ELSE
        MESSAGE 'Object wasnt added';

    FORM documentArticle MODAL CHECK;

    IF (formResult() == formResult.ok) THEN {
        MESSAGE 'You pressed "ok"' LENGTH 50;
        MESSAGE [FORMULA STRING[100] '\'You have choosen article \' || $1 || \' and store \' || $2'](name(chosenObject('article')), name(store(chosenObject('document'))));

        FOR (k == chosenObject('article')) DO {
            SET name(k) <- 'THIS article was chosen in modal form';
        };
        FOR (k == store(chosenObject('document'))) DO {
            SET name(k) <- 'Document for THIS store was chosen in modal form';
        };

        RETURN;
    } ELSE IF (formResult() == formResult.close) THEN {
        MESSAGE 'You pressed "close"';
    };
};

i() = SESSION DATA INTEGER ();
testAction 'Показать "По документам" 3 раза' = ACTION() {
    SET i() <- 0;
    WHILE (i() < 3) DO {
        FORM documentArticle MODAL CHECK;
        IF (formResult() == formResult.ok) THEN {
            MESSAGE 'You pressed "ok"' LENGTH 50;
        } ELSE IF (formResult() == formResult.close) THEN {
            MESSAGE 'You pressed "close"';
        };

        SET i() <- i() + 1;
    };
};

FORM testModalForm 'Показать тестовую модальную форму'
OBJECTS article, i=INTEGER 'Новое имя товара ("Товар %N%"):' FIXED PANEL, store, s=STRING[50] 'Новое имя склада:' FIXED PANEL
PROPERTIES name(article), name(store), OBJVALUE(s), OBJVALUE(i)
;

showTestModalForm 'Показать тестовую форму' = ACTION() {
    FORM testModalForm NEWSESSION MODAL;
    SET name(k) IF k == chosenObject('store') IF (formResult() == formResult.ok) <- chosenString('s');
    SET name(k) IF k == chosenObject('article') IF (formResult() == formResult.ok) <- [FORMULA STRING[30] '$1 || CAST($2 as char(20))']('Товар ', chosenInt('i'));
};

remindPasswordEmail 'Выслать пароль на этот email' (u, to) = ACTION EMAIL
//    FROM 'luxsoft@adsl.by'
    SUBJECT [FORMULA STRING[60] '\'Напоминание пароля для \' || $1'](email(u))
    TO (to IF to IS STRING[200])
    CC 'some@someserv.net'
//    BCC 'luxsoft@adsl.by'
    INLINE remindPasswordLetter OBJECTS customUser=(u AS customUser)
    ATTACH PDF
           NAME [FORMULA STRING[60] '\'ATTACH: Напоминание пароля для \' || $1'](email(u))
           remindPasswordLetter OBJECTS customUser=(u AS customUser)
    ;

FORM testEmailForm 'Тестирование EMAIL'
OBJECTS s=STRING[100] 'Email:' FIXED PANEL, u=customUser
PROPERTIES OBJVALUE(s), userLogin(u), userPassword(u), email(u), ADDOBJ(u), remindPasswordEmail(u, s) TODRAW s
;

stime 'Время' (store) = DATA TIME (store) IN base;
sdate 'Дата' (store) = DATA DATE (store) IN base;
sdatetime 'ДатаВремя' (store) = DATA DATETIME (store) IN base;
sword 'Word' (store) = DATA WORDFILE (store) IN base;
simage 'Image' (store) = DATA IMAGEFILE (store) IN base;
spdf 'PDF' (store) = DATA PDFFILE (store) IN base;
scustom 'Custom file' (store) = DATA CUSTOMFILE (store) IN base;
sexcel 'Excel' (store) = DATA EXCELFILE (store) IN base;
scolor 'Color' (store) = DATA COLOR (store) IN base;

testRequestInput 'Тестование REQUEST input' = ACTION(s) {
    CONFIRM 'Быть или не быть?' LENGTH 100;

    IF (confirmed()) THEN {
        REQUEST COLOR {
            REQUEST COLOR INPUT;
            IF (requestedColor() == #FF0000) THEN {
                SET requestedColor() <- #00FF00;
            }
            SET scolor(s) IF s IS store <- requestedColor();
        }
    } ELSE {
        MESSAGE 'Нет... ';
    }
};

FORM storeArticle 'По складам'
OBJECTS s=store '-Склад-', a=article
PROPERTIES ssel=SELECTION(s), sname=name(s), obja=OBJVALUE(a), aname=name(a)
PROPERTIES TODRAW s FORCE PANEL copyStoreNameToArticles(s), copyStoreNameToArticle(s, a), copyStoreNameToArticleError(s, a), createNewStore(), showDocumentArticleModalForm(), showTestModalForm(), testRequestInput(s)
PROPERTIES(s, a) SHOWIF storeIsHuge(s) incomeQuantity2, outcomeQuantity2
PROPERTIES(s) storeSizeName, ssc1=storeSizeCode, storeIsHuge, stime, sdate, sdatetime, sword, simage, spdf, scustom, sexcel, scolor
PROPERTIES(s, a) incomeQuantity, outcomeQuantity, foo, foo2 SHOWIF storeIsHuge(s), bar, foobar HEADER name(a), bar2, baz, baz2, balanceQuantity, testUnion HEADER name(s), testPartition, testFormula
FILTERGROUP filters1
    FILTER 'Показывать только огромные склады' 'F10' storeIsHuge(s)
ORDER BY sname, foo, ssel
;

FORM editStore 'Редактирование склада'
OBJECTS s=store FIXED PANEL
PROPERTIES(s) name, storeSizeName, storeIsHuge, storeIsHuge2
// To use this form as EDIT\DIALOG\LIST form for some class (for ex. store)
// Use this syntax:
//(EDIT | DIALOG | LIST) <className> OBJECT <objectName>
EDIT store OBJECT s
;

//////////////// INDEX STATEMENT //////////////////
// Syntax:
// INDEX propertyName1 [, ..., propertyNameN];
INDEX quantity, store;


//////////////// WINDOW STATEMENT /////////////////
// Add new window statement
// Syntax:
// WINDOW (MENU | PANEL | TREE | TOOLBAR) <name> '<caption>' [ option [, option ...] ]
// option ::=   HIDETITLE |
//              HIDESCROLLBARS |
//              DRAWROOT |
//              (VERTICAL | HORIZONTAL) |
//              (LEFT | RIGHT | TOP | BOTTOM) |
//              POSITION(x, y, w, h) |
//              HALIGN( LEFT | CENTER | RIGHT ) |
//              VALIGN( TOP | CENTER | BOTTOM ) |
//              TEXTHALIGN( LEFT | CENTER | RIGHT ) |
//              TEXTVALIGN( TOP | CENTER | BOTTOM )
WINDOW TOOLBAR mainToolbar 'Навигатор' VERTICAL LEFT HIDETITLE HALIGN(CENTER) TEXTVALIGN(BOTTOM) TEXTHALIGN(CENTER);
WINDOW TOOLBAR leftToolbar 'Список' VERTICAL POSITION(0, 0, 20, 60);
WINDOW TREE objectsWindow 'Объекты' POSITION(0, 30, 20, 30) DRAWROOT;

//Hide window
HIDE WINDOW System.log;
HIDE WINDOW System.relevantForms;
HIDE WINDOW relevantClassForms;

//////////////// NAVIGATOR STATEMENT /////////////////
//настройка навигатора
NAVIGATOR {
    // чтобы добавить существующий элемент в другой элемент используется команда следующего вида
    // ADD <имя> ['<новый заголовок>'] [(IN | AFTER | BEFORE) <имя>] [TO <новое окно>];
    // при этом по умолчанию он будет добавлен в элемент текущей области видимости
    // (при использовании прямо внутри NAVIGATOR - он будет добавлен в baseElement)
    //
    // для создания нового элемента используется команда:
    // NEW <имя> '<заголовок>' [(IN | AFTER | BEFORE) <имя>] [TO <имя окна>] [ACTION <имя экшена>];

    NEW element1 'Element 1' AFTER userPolicyForm;

    NEW element2 'Element 2' BEFORE userPolicyForm;
    ADD storeArticle IN element2;

    NEW outer 'Outer element' IN element1 {
        ADD dictionariesForm 'Dictionaries' {
            NEW underForm 'under form element';
        }

        ADD element2;
    }

    //при создании элемента можно указать окно для него
    NEW testNavigators '-Тестовые навигаторы-' AFTER adminForm TO mainToolbar;

    // также можно просто настраивать существующий элемент без его перемещения
    testNavigators 'Тестовые навигаторы' {
        ADD element1 {
            //...
        }
        ADD element2;
        ADD underForm;
        ADD editStore;
        ADD testModalForm;

        //если задано имя действия, то создаться элемент для запуска этого действия
        NEW testNavigatorAction 'Показать "По документам" 3 раза' ACTION testAction;
    }
    // так можно отдельно настроить окно, в которое будет рисоваться элемент
    baseElement TO mainToolbar;
    testNavigators TO leftToolbar;
    adminElement TO leftToolbar;
    objectElement TO objectsWindow;

    ADD dictionariesForm 'Словари' AFTER daysOffForm;
    ADD storeArticle;
    ADD documentArticle;
}

//////////////// DESIGN STATEMENT /////////////////
//При создании дизайна по умолчанию создаётся набор контейнеров и компонентов с определёнными именами
//
//Соответсвие между вызовами в Java и именами доступными в настройке дизайна показаны ниже
//(также указан тип объекта - контейнер или компонент):
//
//getMainContainer => CONTAINER main
//
//getTreeContainer => CONTAINER treeName.tree.box
//get(TreeGroupEntity) => COMPONENT treeName.tree
//
//getGroupObjectContainer => CONTAINER groupName.box
//getPanelContainer => CONTAINER groupName.panel
//get(GroupObjectEntity)
//    .grid => COMPONENT groupName.grid
//    .showType => COMPONENT groupName.showType
//getGridContainer => CONTAINER groupName.grid.box
//getControlsContainer => CONTAINER groupName.controls
//getFilterContainer => CONTAINER groupName.filters
//
//getGroupPropertyContainer(AbstractGroup)
//     для групп данного модуля =>  CONTAINER groupName.propGroupName
//     для групп других модулей =>  CONTAINER groupName.moduleName_propGroupName
//
//get(ObjectEntity)
//    .classChooser => COMPONENT objectName.classChooser
//
//getRegularFilterGroup => COMPONENT filters.filterName
//
//get*Function => COMPONENT functions.*
//getFormButtonContainer=> CONTAINER functions.box
//
//get(PropertyDrawEntity) => COMPONENT PROPERTY(propSelector(...))


DESIGN storeArticle FROM DEFAULT {
    // Чтобы добавить контейнер в другой контейнер используется команда '(ADD | NEW ) <имя> [(IN | BEFORE | AFTER) <имя2>]'.
    // При использовании NEW контейнер будет создан, если компонент с таким именем уже существовал, то будет ошибка.
    // При этом по умолчанию он будет добавлен в контейнер текущей области видимости
    // (при использовании прямо внутри DESIGN - он будет добавлен в main контейнер)
    NEW newContainer {
        // будет добавлен в newContainer, т.к. находится в его области видимости
        NEW child1 {
            // будет добавлен в child1, т.к. находится в его области видимости
            NEW child11;
        }

        // будет добавлен в child11, т.к. явно указано куда добавлять
        NEW child2 IN child11;

        // будет добавлен в child1, перед child11, т.к. это явно указано
        NEW child3 BEFORE child11;

        // будет добавлен в child1, после child11, т.к. это явно указано
        NEW child4 AFTER child11;

        NEW child5;

        // для задания intersections используется конструкция вида:
        // POSITION <имя1> (TO THE LEFT | TO THE RIGHT | TO THE BOTTOM | TO THE RIGHTBOTTOM | TO NOT INTERSECT) [<имя2>]
        // например следующая команда добавит intersection для расположения child1 слева от child5;
        POSITION child1 TO THE LEFT child5;

        // при этом компоненты должны быть в одном контейнере, т.е. следующая команда выдаст ошибку:
        // POSITION child2 TO THE LEFT child3;

        ADD child5 {
            // если второе имя емя не указано, то будет использован компонент из данной области видимости
            // т.е. в данном месте команда 'POSITION child1 TO NOT INTERSECT child5' равносильна просто:
            POSITION child1 TO NOT INTERSECT;
        }
    }
    // для удаления компонента используется команда REMOVE <имя> [CASCADE];
    // если CASCADE не указано, то удалится только сам контейнер,
    // а вложенные контейнеры будут доступны для дальнейшей вставки в другие места обычным образом
    // если же CASCADE указано, то удалится сам контейнер со всем вложенными

    // REMOVE newContainer;
    REMOVE newContainer CASCADE;

    // для настройки свойств используется конструкция вида
    //  <имя свойства> = <значение>;
    // при этом будет изменено свойство объекта в текущей области видимости
    // для верхней области видимости будет изменяться сама форма
    //
    // все названия доступных свойств объектов совпадают с таковыми в Java
    // кроме того вложенные свойства constraints.* и component.design.* доступны напрямую
    // например в Java: design.overridePageWidth = 3000;
    // соотвествует
    overridePageWidth = 3000;

    // для формы есть одно исключение для единообразия с другими объектами - вместо caption используется title
    // т.е. в Java: richDesign.caption = "Справочник складов"; соотвествует
    title = 'Справочник складов';


    // для того, чтобы просто настроить свойства объекта без добавления его в текущий контейнер,
    // используется следующая конструкция
    main {
        title = 'Главный контейнер';

        ADD functions.box BEFORE s.box;

        a.box {
            title = 'Артикль';
            fillHorizontal = 2.5;
        }

        s.box {
            // в Java: someComponent.constraints.fillVertical = 0.3; соответсвует
            fillVertical = 0.2;

            //здесь всё так же можно применять команды ADD, POSITION и т.д.
            NEW child1 {
                // так контейнер будет отображаться в виде табов
                // соответсвует в Java: container.type = ContainerType.TABBED_PANE;
                type = TABBED;
                // а так - в виде SplitPane'а: type = SPLITV
                //                             type = SPLITH

                NEW child2;

                // настраивать объекты можно в любой области видимости - это ни на что не повлияет
                s.box {
                    fillVertical = 0.3;
                }
            }
            REMOVE child1 CASCADE;
        }
    }

    //для настройки GroupObjectView используется следующая конструкция
    GROUP(s) {
        tableRowsCount = 10;
        needVerticalScroll = FALSE;
    }


    //для доступа к компоненту свойства (PropertyDrawView) используется следующая конструкция
    //здесь просто выберется 1й компонент для конкретного свойства
    PROPERTY(bar) { caption = 'Барр'; }

    //здесь - компонент для свойства с определённым мэппингом
    PROPERTY(storeSizeName(s)) { caption = 'Имя размера склада'; }

    PROPERTY(foo(s, a)) {
        focusable = FALSE;
        panelLabelAbove = TRUE;
        caption = 'This is foo\'s caption!';
    }

    // настройка некоторых других свойств
//    PROPERTY(name(a)) {
    PROPERTY(aname) {
        // настройка свойств, соответсвующих клавишам
        showEditKey = TRUE;
        editKey = 'ctrl F6';
        caption = 'Имя (a)';

        // шрифт
        headerFont = 'Tahoma bold italic 15';
        headerFont = 'Tahoma bold 13';
        headerFont = 'Tahoma 12';

        //toolbar/shortcut. свойство предварительно нужно отправить в панель
//        panelLocation = TOOLBAR;
//        panelLocation = SHORTCUT;
//        panelLocation = SHORTCUT storeSizeName; // единственное свойство, для которого отображается name(a) в shortcut
//        panelLocation = SHORTCUT DEFAULT;   // DEFAULT используется при помещении в shortcut какого-нибудь actionProperty
//        panelLocation = SHORTCUT storeSizeName DEFAULT;
    }

    NEW setupEx {
        // Dimension
        minimumSize = (100, 200);

        // constraints.childConstraints
        childConstraints = TO THE LEFT;
        childConstraints = TO THE RIGHT;
        childConstraints = TO NOT INTERSECT;

        //Insets
        insetsInside = ( -100, -200, 300, 400);
    }
    REMOVE setupEx;
}

//////////////// METACODE STATEMENT /////////////
// Syntax:
// META codeName([param1, ..., paramN]) metacode END
//
// Metacode usage syntax:
// @codeName([[param1], ..., [paramN]]);
//
// concatenation operator: ##
// concatenation capitalize operator: ###

META metaCodeSample(name)
    CLASS name##Class;
    GROUP name ### group;
END

@metaCodeSample(testName1);
@metaCodeSample(testName2);


//////////////// TABLE STATEMENT ////////////////
// Syntax:
// TABLE name(className1, ..., classNameN);
TABLE articleStore(article, store);
