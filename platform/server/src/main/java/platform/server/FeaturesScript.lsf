MODULE Features;

IMPORT BaseLogicsModule;

/////////// GROUP STATEMENT ////////////

// Syntax:
// GROUP name ['caption'] [: parentGroup];
GROUP base 'Основная группа' : baseGroup;
GROUP simpleGroup;
GROUP sampleGroup : BaseLogicsModule.baseGroup; // явная квалификация имен

/////////// CLASS STATEMENT ////////////

// Non-static class
// Syntax:
// CLASS [ABSTRACT] name ['caption'] [: nonStaticBaseClass1 [, nonStaticBaseClass2, ..., nonStaticBaseClassN]];
CLASS ABSTRACT namedClass : named;
CLASS emptyClass;
CLASS article 'Товар' : namedClass;
CLASS store 'Склад' : namedClass;
CLASS document 'Документ' : transaction;
CLASS incomeDocument 'Приход' : document, emptyClass;
CLASS outcomeDocument 'Расход' : document, emptyClass;

// Static class
// Syntax:
// CLASS STATIC name ['caption'] {
//      instanceName1 ['instanceCaption1']
//      [, instanceName2 ['instanceCaption2']]
//      ...
//      [, instanceNameN ['instanceCaptionN']]
// }
// [: nonStaticBaseClass1 [, nonStaticBaseClass2, ..., nonStaticBaseClassN];]
CLASS STATIC storeSize 'Размер склада'
{
    huge 'огромный',
    big 'большой',
    medium 'средний',
    small 'маленький'
}


//////////// PROPERTY STATEMENT///////////
// Common syntax:
// name ['caption'] [(namedParam1, ..., namedParamN)] = propertyExpression [IN group] [PERSISTENT] [TOOLBAR | (SHORTCUT [propertyExpression] [DEFAULT])] [FIXEDCHARWIDTH <int value>] [MINCHARWIDTH <int value>] [MAXCHARWIDTH <int value>] [PREFCHARWIDTH <int value>]
//                                                                                                 [IMAGE 'name'] [EDITKEY '<key code>' [SHOW | HIDE]] [AUTOSET];
// Если именованные параметры не указываются, то они выводятся из propertyExpression

// Data property
// Expression syntax:
// DATA returnClass ( [paramClass1, ..., paramClassN] )
// Built-in types: INTEGER, LONG, DOUBLE, BOOLEAN, DATE, DATETIME, TEXT, STRING, ISTRING
store = DATA store (document) IN base;
quantity = DATA DOUBLE (document, article) IN base;
storeSize = DATA storeSize (store) IN base;

// Join property
// Expression syntax:
// (name | '[' propertyDefinition ']') (param1, ..., paramN)
storeName 'Склад' (document) = name(store(document)) IN base;
storeSizeName = name(storeSize(store)) IN base; // можем не указывать именованные параметры слева от '=', но все равно пользоваться ими
objectIsStore = [IS store](object);             // аналог: object IS store

// IS, AS
// Expression syntax:
// propertyExpression (AS | IS) className
// IS - is(), AS - object()
isIncomeDocument(document) = document IS incomeDocument;


// AND, IF (идентичны по действию)
// Expression syntax:
// propertyExpression (AND | IF) [NOT] propertyExpression
inQuantity(document, article) = quantity(document, article) IF isIncomeDocument(document);
outQuantity(document, article) = quantity($1, $2) IF $1 IS outcomeDocument;  // указание номеров параметров вместо имен

// Group property
// SUM, MAX, MIN group property
// Expression syntax:
// GROUP (SUM | MAX | MIN) propertyExpression [BY propertyExpression1, ..., propertyExpressionN]
incomeQuantity(store, article) = GROUP SUM inQuantity(document, article) BY store(document), article;
outcomeQuantity(store, article) = GROUP SUM outQuantity(doc, art) BY store(doc), art;

incomeQuantity2(store, article) = GROUP SUM quantity(document, article) IF document IS incomeDocument BY store(document), article;
outcomeQuantity2(store, article) = GROUP SUM quantity(doc, art) IF doc IS outcomeDocument BY store(doc), art;

// CONCAT group property
// GROUP CONCAT propertyExpr, separatorPropertyExpr [BY propertyExpr1, ..., propertyExprN] [ORDER [DESC] orderPropertyExpr1, ..., orderPropertyExprK]
allNames() = GROUP CONCAT name(obj) IF obj IS named, ', ' ORDER DESC name(obj);

// UNIQUE group property
// GROUP UNIQUE propertyExpression [BY propertyExpression1, ..., propertyExpressionN] [WHERE propertyExpression]
nameToCountry(name) = GROUP UNIQUE country BY name(country);

// Union property
// Expression syntax:
// UNION (SUM | MAX | OVERRIDE | XOR | EXCLUSIVE) propertyExpression1, ..., propertyExpressionN
testUnion(store, article) = UNION SUM incomeQuantity(store, article), outcomeQuantity(store, article);

// Partition property
// Expression syntax:
// PARTITION (SUM | PREV) propertyExpression
// [BY propertyExpressionM1, ..., propertyExpressionMN]
// [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
// [WINDOW EXCEPTLAST]
testPartition(store, article) = PARTITION SUM incomeQuantity(store, article) BY store ORDER DESC name(article);

// Formula property
// Expression syntax:
// FORMULA primitiveType 'formula text $1 + $2'
sum12 = FORMULA DOUBLE '($1)+($2)*2';
testFormula(store, article) = sum12(incomeQuantity(store, article), outcomeQuantity(store, article));

// Computational expressions
// Priority:
// AND  IF
// ==  !=
// <  >  <=  >=
// +  -
// *  /
// - (unary)
//
// Instances: 5, 6.35, TRUE, 'some string', staticClass.object
balanceQuantity(store, article) = incomeQuantity(store, article) - outcomeQuantity(store, article);

foo(store, article) = 5 * incomeQuantity($1, $2) - outcomeQuantity($1, $2);
foo2(store, article) = - outcomeQuantity(store, article) + 5 * incomeQuantity(store, article);
bar = incomeQuantity(store, article) * 5 - 3 - 4 + outcomeQuantity(store, article);
bar2(store, article) = 3.5 * incomeQuantity($1, $2) - (-5 + outcomeQuantity($1, $2));
foobar(store, article) = [x*x + y](foo(store, article), bar(store, article));   // lambda-like syntax
baz(store, article) = bar(store, article) > bar2(store, article) IN base;
baz2 = foo(s, a) >= 15 == foo2(s, a) >= 15;

storeIsHuge(store) = storeSize(store) == storeSize.huge;                        // static class instance
storeIsHuge2(store) = (storeSize(store) == storeSize.huge) == TRUE;

documentBalance(document, article) = balanceQuantity(store(document), article);

///////////////CONSTRAINT STATEMENT//////////////
// Syntax:
// CONSTRAINT [CHECKED] propertyExpression MSG 'message';
CONSTRAINT CHECKED foo(store, article) > 1000 MSG 'ошибка: >1000';


////////////////FOLLOWS STATEMENT////////////////
// Syntax:
// propertyName(param1, ..., paramN) =>
//      propertyExpression1 [RESOLVE (TRUE | FALSE | ALL | NOTHING)],
//      ...
//      propertyExpressionK [RESOLVE (TRUE | FALSE | ALL | NOTHING)];
//foo(store, article) => foo2(store, article) RESOLVE NOTHING;

////////////////ACTION STATEMENT////////////////
// Syntax:
// ACTION(param1, ..., paramN) {
//     (    propertyExpression <- propertyExpression2;
//     |    propertyExpression <- NULL;
//     |    propertyExpression <- DEFAULT;
//     |    propertyExpression;
//     )*
// }
//
copyStoreNameToArticles(s) = ACTION (s) {
    (name(a) AND a IS article) <- (name(s) AND s IS store);
};

createNewStore 'Добавить большой склад' = ACTION () {
    [ADDOBJ store]();

    name(k) IF k == addedObject() <- [FORMULA STRING[20] '$1 || CAST($2 as char(20))']('New store ', addedObject());
    storeSize(k) IF k == addedObject() <- storeSize.big;
} TOOLBAR IMAGE 'add.png';

//////////////WRITEONCHANGE STATEMENT////////////
// Syntax:
// propertyName(param1, ..., paramN) <- [OLD] valuePropertyExpression ON (ASSIGN | CHANGE) changePropertyExpression


//////////////// FORM STATEMENT /////////////////
// Syntax:
// FORM name ['caption']
// [(Objects list | Properties list | Filters list)]
// ...
// [(Objects list | Properties list | Filters list)];
FORM documentArticle 'По документам'

// Objects list syntax:
// OBJECTS [alias=] className ['<caption>'] | [groupAlias=] ([alias1=] className1 ['<caption1>'], ..., [aliasN=] classNameN ['<captionN>']) [INIT | FIXED] [PANEL | HIDE | GRID],
//         ...
//         [alias=] className ['<caption>'] | [groupAlias=] ([alias1=] className1 ['<caption1>'], ..., [aliasN=] classNameN ['<captionN>']) [INIT | FIXED] [PANEL | HIDE | GRID]
OBJECTS document, article

// TreeGroup syntax:
// TREE [SID] [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] ([alias1=] className1 ['<caption1>'], ..., [aliasN=] classNameN ['<captionN>']) [PARENT <properties separated with space>],
//            ...
//            [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] ([alias1=] className1 ['<caption1>'], ..., [aliasN=] classNameN ['<captionN>']) [PARENT <properties separated with space>]

// Property list syntax:
// PROPERTIES propName1(param1, ..., paramN1), ..., propNameK(param1, ..., paramNK)
// Special properties: SELECTION, OBJVALUE, ADDOBJ
// Property options:    [READONLY] [COLUMNS (<groupObject list>)] [SHOWIF <mappedProperty>] [HIGHLIGHTIF <mappedProperty>]
//                      [HEADER <mappedProperty>] [FOOTER <mappedProperty>] [FORCE PANEL | HIDE | GRID] [TODRAW <groupObject>]

PROPERTIES store(document), name(article), storeName(document)
PROPERTIES quantity(document, article)
PROPERTIES inQuantity(document, article), outQuantity(document, article), documentBalance(document, article)
PROPERTIES ADDOBJ(document), ADDOBJ(article)

// Filters list syntax:
// FILTERS NOT NULL property1(param1, ..., paramN1),
//         ...
//         NOT NULL propertyK(param1, ..., paramNK)
FILTERS NOT NULL name(article);


FORM storeArticle 'По складам'
OBJECTS s=store '-Склад-', a=article
PROPERTIES SELECTION(s), name(s) READONLY, OBJVALUE(a), name(a), copyStoreNameToArticles(s) FORCE PANEL, createNewStore() TODRAW s FORCE PANEL
PROPERTIES(s, a) SHOWIF storeIsHuge(s) incomeQuantity, incomeQuantity2, outcomeQuantity, outcomeQuantity2
PROPERTIES(s) storeSizeName, storeIsHuge, storeIsHuge2
PROPERTIES(s, a) foo, foo2 SHOWIF storeIsHuge(s), bar, foobar HEADER name(a), bar2, baz, baz2, balanceQuantity, testUnion HEADER name(s), testPartition, testFormula
FILTERGROUP filters1
    FILTER 'Показывать только огромные склады' 'F10' NOT NULL storeIsHuge(s)
ORDER BY name, foo
;

FORM editStore 'Редактирование склада'
OBJECTS s=store FIXED PANEL
PROPERTIES(s) name, storeSizeName, storeIsHuge, storeIsHuge2
// To use this form as EDIT\DIALOG\LIST form for some class (for ex. store)
// Use this syntax:
//(EDIT | DIALOG | LIST) <className> OBJECT <objectName>
EDIT store OBJECT s
;

// Form action property
// Expression syntax:
// ACTION FORM formName
// [OBJECTS object1, ..., objectN]
// [SET propertyExpr1, ..., propertyExprM]
// [CLASS className]
// [NEWSESSION] [MODAL]
showForm(document) = ACTION FORM documentArticle OBJECTS document NEWSESSION MODAL;


//////////////// WINDOW STATEMENT /////////////////
// Add new window statement
// Syntax:
// WINDOW (MENU | PANEL | TREE | TOOLBAR) <name> '<caption>' [ option [, option ...] ]
// option ::=   HIDETITLE |
//              HIDESCROLLBARS |
//              DRAWROOT |
//              (VERTICAL | HORIZONTAL) |
//              (LEFT | RIGHT | TOP | BOTTOM) |
//              POSITION(x, y, w, h) |
//              HALIGN( LEFT | CENTER | RIGHT ) |
//              VALIGN( TOP | CENTER | BOTTOM ) |
//              TEXTHALIGN( LEFT | CENTER | RIGHT ) |
//              TEXTVALIGN( TOP | CENTER | BOTTOM )
WINDOW TOOLBAR mainToolbar 'Навигатор' VERTICAL LEFT HIDETITLE HALIGN(CENTER) TEXTVALIGN(BOTTOM) TEXTHALIGN(CENTER);
WINDOW TOOLBAR leftToolbar 'Список' VERTICAL POSITION(0, 0, 20, 60);
WINDOW TREE objectsWindow 'Объекты' POSITION(0, 30, 20, 30) DRAWROOT;

//Hide window
HIDE WINDOW BaseLogicsModule.log;
HIDE WINDOW BaseLogicsModule.relevantForms;
HIDE WINDOW relevantClassForms;

//////////////// NAVIGATOR STATEMENT /////////////////
//настройка навигатора
NAVIGATOR {
    // чтобы добавить существующий элемент в другой элемент используется команда следующего вида
    // ADD <имя> ['<новый заголовок>'] [(IN | AFTER | BEFORE) <имя>] [TO <новое окно>];
    // при этом по умолчанию он будет добавлен в элемент текущей области видимости
    // (при использовании прямо внутри NAVIGATOR - он будет добавлен в baseElement)
    //
    // для создания нового элемента используется команда:
    // NEW <имя> '<заголовок>' [(IN | AFTER | BEFORE) <имя>] [TO <имя окна>];

    NEW element1 'Element 1' AFTER userPolicyForm;

    NEW element2 'Element 2' BEFORE userPolicyForm;
    ADD storeArticle IN element2;

    NEW outer 'Outer element' IN element1 {
        ADD dictionariesForm 'Dictionaries' {
            NEW underForm 'under form element';
        }

        ADD element2;
    }

    //при создании элемента можно указать окно для него
    NEW testNavigators '-Тестовые навигаторы-' AFTER remindPasswordLetter TO mainToolbar;

    // также можно просто настраивать существующий элемент без его перемещения
    testNavigators 'Тестовые навигаторы' {
        ADD element1 {
            //...
        }
        ADD element2;
        ADD underForm;
    }
    // так можно отдельно настроить окно, в которое будет рисоваться элемент
    baseElement TO mainToolbar;
    testNavigators TO leftToolbar;
    adminElement TO leftToolbar;
    objectElement TO objectsWindow;

    ADD dictionariesForm 'Словари' AFTER daysOffForm;
    ADD storeArticle;
}

//////////////// DESIGN STATEMENT /////////////////
//При создании дизайна по умолчанию создаётся набор контейнеров и компонентов с определёнными именами
//
//Соответсвие между вызовами в Java и именами доступными в настройке дизайна показаны ниже
//(также указан тип объекта - контейнер или компонент):
//
//getMainContainer => CONTAINER main
//
//getTreeContainer => CONTAINER treeName.box
//get(TreeGroupEntity) => COMPONENT treeName.tree
//
//getGroupObjectContainer => CONTAINER groupName.box
//getPanelContainer => CONTAINER groupName.panel
//get(GroupObjectEntity)
//    .grid => COMPONENT groupName.grid
//    .showType => COMPONENT groupName.showType
//getGridContainer => CONTAINER groupName.grid.box
//getControlsContainer => CONTAINER groupName.controls
//getFilterContainer => CONTAINER groupName.filters
//
//getGroupPropertyContainer(AbstractGroup)
//     для групп данного модуля =>  CONTAINER groupName.propGroupName
//     для групп других модулей =>  CONTAINER groupName.moduleName_propGroupName
//
//get(ObjectEntity)
//    .classChooser => COMPONENT objectName.classChooser
//
//getRegularFilterGroup => COMPONENT filters.filterName
//
//get*Function => COMPONENT functions.*
//getFormButtonContainer=> CONTAINER functions.box
//
//get(PropertyDrawEntity) => COMPONENT PROPERTY(propSelector(...))


DESIGN storeArticle FROM DEFAULT {
    // чтобы добавить контейнер в другой контейнер используется команда 'ADD <имя>' [(IN | BEFORE | AFTER) <имя2>]
    // если контейнер не существовал, то он будет создан
    // при этом по умолчанию он будет добавлен в контейнер текущей области видимости
    // (при использовании прямо внутри DESIGN - он будет добавлен в main контейнер)
    ADD newContainer {
        // будет добавлен в newContainer, т.к. находится в его области видимости
        ADD child1 {
            // будет добавлен в child1, т.к. находится в его области видимости
            ADD child11;
        }

        // будет добавлен в child11, т.к. явно указано куда добавлять
        ADD child2 IN child11;

        // будет добавлен в child1, перед child11, т.к. это явно указано
        ADD child3 BEFORE child11;

        // будет добавлен в child1, после child11, т.к. это явно указано
        ADD child4 AFTER child11;

        ADD child5;

        // для задания intersections используется конструкция вида:
        // POSITION <имя1> (TO THE LEFT | TO THE RIGHT | TO THE BOTTOM | TO THE RIGHTBOTTOM | TO NOT INTERSECT) [<имя2>]
        // например следующая команда добавит intersection для расположения child1 слева от child5;
        POSITION child1 TO THE LEFT child5;

        // при этом компоненты должны быть в одном контейнере, т.е. следующая команда выдаст ошибку:
        // POSITION child2 TO THE LEFT child3;

        ADD child5 {
            // если второе имя емя не указано, то будет использован компонент из данной области видимости
            // т.е. в данном месте команда 'POSITION child1 TO NOT INTERSECT child5' равносильна просто:
            POSITION child1 TO NOT INTERSECT;
        }
    }
    // для удаления компонента используется команда REMOVE <имя> [CASCADE];
    // если CASCADE не указано, то удалится только сам контейнер,
    // а вложенные контейнеры будут доступны для дальнейшей вставки в другие места обычным образом
    // если же CASCADE указано, то удалится сам контейнер со всем вложенными

    // REMOVE newContainer;
    REMOVE newContainer CASCADE;

    // для настройки свойств используется конструкция вида
    //  <имя свойства> = <значение>;
    // при этом будет изменено свойство объекта в текущей области видимости
    // для верхней области видимости будет изменяться сама форма
    //
    // все названия доступных свойств объектов совпадают с таковыми в Java
    // кроме того вложенные свойства constraints.* и component.design.* доступны напрямую
    // например в Java: design.overridePageWidth = 3000;
    // соотвествует
    overridePageWidth = 3000;

    // для формы есть одно исключение для единообразия с другими объектами - вместо caption используется title
    // т.е. в Java: richDesign.caption = "Справочник складов"; соотвествует
    title = 'Справочник складов';


    // для того, чтобы просто настроить свойства объекта без добавления его в текущий контейнер,
    // используется следующая конструкция
    main {
        title = 'Главный контейнер';

        ADD functions.box BEFORE s.box;

        a.box {
            title = 'Артикль';
            fillHorizontal = 2.5;
        }

        s.box {
            // в Java: someComponent.constraints.fillVertical = 0.3; соответсвует
            fillVertical = 0.2;

            //здесь всё так же можно применять команды ADD, POSITION и т.д.
            ADD child1 {
                // так контейнер будет отображаться в виде табов
                // соответсвует в Java: container.tabbedPane = true;
                tabbedPane = TRUE;

                ADD child2;

                // настраивать объекты можно в любой области видимости - это ни на что не повлияет
                s.box {
                    fillVertical = 0.3;
                }
            }
            REMOVE child1 CASCADE;
        }
    }

    //для настройки GroupObjectView используется следующая конструкция
    GROUP(s) {
        tableRowsCount = 10;
        needVerticalScroll = FALSE;
    }


    //для доступа к компоненту свойства (PropertyDrawView) используется следующая конструкция
    //здесь просто выберется 1й компонент для конкретного свойства
    PROPERTY(bar) { caption = 'Барр'; }

    //здесь - компонент для свойства с определённым мэппингом
    PROPERTY(storeSizeName(s)) { caption = 'Имя размера склада'; }

    a.panel {
        ADD nameContainer {
            title = 'Отдельный контейнер для имени в панели';
            ADD PROPERTY(name(a)) {
                caption = 'Имя (a)';
                showEditKey = TRUE;
                clearText = TRUE;
            }
        }
    }

    PROPERTY(foo(s, a)) {
        focusable = FALSE;
        panelLabelAbove = TRUE;
        caption = 'This is foo\'s caption!';
    }

    // настройка некоторых других свойств
    PROPERTY(name(a)) {
        // настройка свойств, соответсвующих клавишам
        editKey = 'ctrl F6';

        // шрифт
        headerFont = 'Tahoma bold italic 15';
        headerFont = 'Tahoma bold 13';
        headerFont = 'Tahoma 12';

        //toolbar/shortcut. свойство предварительно нужно отправить в панель
        panelLocation = TOOLBAR;
        panelLocation = SHORTCUT;
        panelLocation = SHORTCUT storeSizeName; // единственное свойство, для которого отображается name(a) в shortcut
        panelLocation = SHORTCUT DEFAULT;   // DEFAULT используется при помещении в shortcut какого-нибудь actionProperty
//        panelLocation = SHORTCUT storeSizeName DEFAULT;
    }

    ADD setupEx {
        // Dimension
        minimumSize = (100, 200);

        // constraints.childConstraints
        childConstraints = TO THE LEFT;
        childConstraints = TO THE RIGHT;
        childConstraints = TO NOT INTERSECT;

        //Insets
        insetsInside = (-100, -200, 300, 400);
    }
    REMOVE setupEx;
}

//////////////// METACODE STATEMENT /////////////
// Syntax:
// META codeName([param1, ..., paramN]) metacode END
//
// Metacode usage syntax:
// @codeName([param1, ..., paramN]);
//
// concatenation operator: ##

META metaCodeSample(name)
    CLASS name##Class;
    GROUP name ## Group;
END

@metaCodeSample(testName1);
@metaCodeSample(testName2);


//////////////// TABLE STATEMENT ////////////////
// Syntax:
// TABLE name(className1, ..., classNameN);
TABLE articleStore(article, store);
