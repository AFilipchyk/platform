MODULE RomanStock;

REQUIRE Stock, Barcode, Supplier, RomanLogicsModule;

PRIORITY Stock, RomanLogicsModule;

EXTEND FORM dialogSku
    PROPERTIES(s) READONLY FORCE GRID nameCategoryArticleSku, nameBrandSupplierArticleSku, sidArticleSku,
                             sidSizeSupplierItem, sidColorSupplierItem, nameColorSupplierItem
;

// implement абстрактных свойств
descriptionItem 'Наименование товара' (item) =
        [FORMULA STRING[200] ' CAST($1 AS TEXT) || \'/\' || CAST($2 AS TEXT) || \'/\' || CAST($3 AS TEXT) || \' (\' || CAST($4 AS TEXT) || \', \' || CAST($5 AS TEXT) || \')\''](
        sidArticleSku(item), sidSizeSupplierItem(item), sidColorSupplierItem(item), nameCategoryArticleSku(item), nameBrandSupplierArticleSku(item));

nameSku(sku) += descriptionItem (sku);

// Единицы измерения
UOMSku (sku) += unitOfMeasureArticleSku (sku);

EXTEND FORM UOM
    PROPERTIES(u) nameOrigin, sidUnitOfMeasure
;

EXTEND FORM UOMs
    PROPERTIES(u) READONLY FORCE GRID nameOrigin, sidUnitOfMeasure
;

// объявляем группы sku
@defineHierarchy(category);
EXTEND FORM category
    PROPERTIES (c) nameParentCategory;
;

parentSkuGroup (skuGroup) += parentCategory(skuGroup);
skuGroupSku (sku) += categoryArticleSku(sku);

// добавляем еще один регистр (бухгалтерский)
@defineSkuLedgerBalanceProperties(A, ' (бухг.)');

EXTEND FORM currentBalanceSkuStock
    PROPERTIES(s, st) currentBalanceASkuStock, averagePriceASkuStock, currentSumASkuStock
    PROPERTIES(bil) skipSkuLedger, skipASkuLedger
    PROPERTIES(bt, st) currentBalanceABatchStock
;

currentBalanceArticleStock 'Тек. остаток' = GROUP SUM currentBalanceSkuStock(sku, stock) BY articleSku(sku), stock PERSISTENT;
currentBalanceArticle 'Тек. остаток' = GROUP SUM currentBalanceArticleStock(article, stock) BY article PERSISTENT;

// создаем разные типы партий (бухгалтерские, управленческие)
//CLASS STATIC batchType {
//    batchTypeA 'Бухгалтерская',
//    batchTypeB 'Управленческая'
//}

//orderABatchType (type) = IF type == batchType.batchTypeA THEN 0 IF type == batchType.batchTypeA ELSE 1 IF type IS batchType PERSISTENT;
//orderBBatchType (type) = IF type == batchType.batchTypeB THEN 0 IF type == batchType.batchTypeB ELSE 1 IF type IS batchType PERSISTENT;
//
//batchTypeBatch = ABSTRACT batchType (batch) PERSISTENT;
//nameBatchTypeBatch 'Тип партии' (batch) = name(batchTypeBatch(batch)) IN baseGroup;

//orderABatch (batch) = orderABatchType(batchTypeBatch(batch)) PERSISTENT;
//orderBBatch (batch) = orderBBatchType(batchTypeBatch(batch)) PERSISTENT;

//META implementABatch (concrete, skuProp)
//    @implementBatch(concrete, skuProp);
//    batchTypeBatch (batch) += batchType.batchTypeA IF batch IS concrete##Detail;
//END
//
//META implementBBatch (concrete, skuProp)
//    @implementBatch(concrete, skuProp);
//    batchTypeBatch (batch) += batchType.batchTypeB IF batch IS concrete##Detail;
//END

CLASS ABSTRACT batchA 'Бухгалтерская партия' : batch;
CLASS ABSTRACT batchB 'Управленческая партия' : batch;

orderABatch (batch) = IF batch IS batchA THEN 0 IF batch IS batchA ELSE 1 IF batch IS batchB PERSISTENT;
orderBBatch (batch) = IF batch IS batchB THEN 0 IF batch IS batchB ELSE 1 IF batch IS batchA PERSISTENT;

META implementSkuLedgerOutFIFOBalanceA (concrete, skuProp, stockProp)
    @implementSkuLedgerOutFIFOBalance (concrete, skuProp, stockProp);
    orderOutFIFOSkuLedgerBatch (ledger, batch) += orderABatch(batch) IF ledger IS concrete##Detail;
END

META implementSkuLedgerOutFIFOBalanceB (concrete, skuProp, stockProp)
    @implementSkuLedgerOutFIFOBalance (concrete, skuProp, stockProp);
    orderOutFIFOSkuLedgerBatch (ledger, batch) += orderBBatch(batch) IF ledger IS concrete##Detail;
END

// ------------------------------------------------- Внутренние партии ----------------------------------------- //
ownerBatchA = ABSTRACT company(batchA) PERSISTENT;
nameOwnerBatchA 'Собственник' (batch) = name(ownerBatchA(batch)) IN baseGroup;

commissionContractSkuBatchA = ABSTRACT contractSku (batchA) PERSISTENT INDEXED;
numberCommissionContractSkuBatchA 'Номер договора комиссии' (batch) = numberContract(commissionContractSkuBatchA(batch)) IN baseGroup;

importerPriceBatchA 'Цена импортера' (batchA) = ABSTRACT NUMERIC[14,2] (batchA) PERSISTENT;

supplierPriceBatchA 'Цена поставщика' (batchA) = ABSTRACT NUMERIC[14,2] (batchA) PERSISTENT;
supplierSumSkuLedger 'Сумма поставщика' (ledger) = GROUP SUM costSkuLedgerBatch(ledger, batch) * supplierPriceBatchA(batch) BY ledger;

rangeVATBatchA (batchA) = ABSTRACT range (batchA) PERSISTENT;
numberSupplierVATBatchA 'НДС, номер' (batchA) = numberRange(rangeVATBatchA(batchA));
valueSupplierVATBatchA 'НДС,%' (batchA) = valueRateRangeDate
    (rangeVATBatchA(batchA), dateBatch(batchA));

CONSTRAINT taxRange(rangeVATBatchA(batchA)) != tax.taxVAT CHECKED BY rangeVATBatchA MESSAGE 'ошибка: Шкала должна соответствовать шкале НДС';

EXTEND FORM currentBalanceSkuStock
    PROPERTIES(bt) nameOwnerBatchA FORCE GRID
;

EXTEND FORM costSkuLedger
    PROPERTIES(bt) READONLY importerPriceBatchA, supplierPriceBatchA, numberSupplierVATBatchA, valueSupplierVATBatchA
;

quantityPackSku 'Количество в грузовом месте' = DATA NUMERIC[9,3] (sku);
