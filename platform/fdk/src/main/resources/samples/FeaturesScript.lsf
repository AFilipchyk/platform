//////////////// MODULE HEADER //////////////////
// Syntax:
// MODULE moduleName;
// [REQUIRE moduleName1, ..., moduleNameN;]
// [PRIORITY namespace1, ..., namespaceK;]
// [NAMESPACE namespaceName;]

MODULE Features;

REQUIRE System, I18n, Utils, Country;

/////////// GROUP STATEMENT ////////////

// Syntax:
// GROUP name ['caption'] [: parentGroup];
GROUP base 'Основная группа' : baseGroup;
GROUP simpleGroup;
GROUP sampleGroup : System.baseGroup; // явная квалификация имен

/////////// CLASS STATEMENT ////////////

// Non-static class
// Syntax:
// CLASS [ABSTRACT] name ['caption'] [: nonStaticBaseClass1 [, nonStaticBaseClass2, ..., nonStaticBaseClassN]];
CLASS ABSTRACT namedClass : named;
CLASS emptyClass;
CLASS article 'Товар' : namedClass;
CLASS store 'Склад' : namedClass;
CLASS ABSTRACT document 'Документ' : transaction;
CLASS incomeDocument 'Приход' : document;
CLASS outcomeDocument 'Расход' : document, emptyClass;

// Static class
// Syntax:
// CLASS STATIC name ['caption']
// [{
//      instanceName1 ['instanceCaption1'],
//      ...
//      instanceNameN ['instanceCaptionN']
// }]
// [: nonStaticBaseClass1 [, nonStaticBaseClass2, ..., nonStaticBaseClassN];]

CLASS STATIC emptyInst;

CLASS STATIC storeSize 'Размер склада' {}

EXTEND CLASS storeSize
{
    huge 'огромный',
    big 'большой'
}

// Extending class
// Syntax:
// EXTEND CLASS className
// [{
//      instanceName1 ['instanceCaption1']
//      ...
//      instanceNameN ['instanceCaptionN']
// }]
// [: nonStaticBaseClass1 [, nonStaticBaseClass2, ..., nonStaticBaseClassN];]
EXTEND CLASS incomeDocument : emptyClass;

EXTEND CLASS Features.storeSize
{
    medium 'средний',
    small 'маленький'
}


//////////// PROPERTY STATEMENT///////////
// Common syntax:
// name ['caption'] [(namedParam1, ..., namedParamN)] = propertyExpression [IN group] [PERSISTENT] [TABLE <table name>] [TOOLBAR | (SHORTCUT propertyExpression [DEFAULT])]
//                                                                                                 [FIXEDCHARWIDTH <int value>]
//                                                                                                 [MINCHARWIDTH <int value>]
//                                                                                                 [MAXCHARWIDTH <int value>]
//                                                                                                 [PREFCHARWIDTH <int value>]
//                                                                                                 [IMAGE 'name'] [EDITKEY '<key code>' [SHOW | HIDE]] [AUTOSET] [CONFIRM]
//                                                                                                 [REGEXP '<expression>' ['<regExp message>']] [LOGGABLE] [ECHO] [INDEXED]
//                                                                                                 [AGGPROP] [NOT NULL [DELETE [SESSION]]] [ON (CHANGE | CHANGEWYS) action]
//                                                                                                 [EVENTID 'id'];

// Если именованные параметры не указываются, то они выводятся из propertyExpression
// Специальные имена свойств: PREV, CHANGED, ASSIGNED

// Data property
// Expression syntax:
// [SESSION] DATA returnClass ( [paramClass1, ..., paramClassN] )
// If SESSION modifier is spesified, than session data property will be created.
// Built-in types: INTEGER, LONG, DOUBLE, BOOLEAN, DATE, DATETIME, TEXT, STRING, ISTRING, TIME, WORDFILE, IMAGEFILE, PDFFILE, CUSTOMFILE, EXCELFILE, NUMERIC, COLOR
store(document) = DATA store (document) IN base;
quantity(document, article) = DATA DOUBLE (document, article) IN base;
storeSize(store) = DATA storeSize (store) IN base;

sessionObj() = SESSION DATA object ();

// Join property
// Expression syntax:
// (name | '[' propertyDefinition ']') (param1, ..., paramN)
storeName 'Склад' (document) = name(store(document)) IN base;
storeSizeName = name(storeSize(store)) IN base; // можем не указывать именованные параметры слева от '=', но все равно пользоваться ими
objectIsStore = [IS store](object);             // аналог: object IS store

// IS, AS
// Expression syntax:
// propertyExpression (AS | IS) className
// IS - is(), AS - object()
isIncomeDocument(document) = document IS incomeDocument;


// AND, IF (идентичны по действию)
// Expression syntax:
// propertyExpression (AND | IF) [NOT] propertyExpression
inQuantity(document, article) = quantity(document, article) IF isIncomeDocument(document);
outQuantity(document, article) = quantity($1, $2) IF $1 IS outcomeDocument;  // указание номеров параметров вместо имен

// Group property
// SUM, MAX, MIN, EQUAL group property
// Expression syntax:
// GROUP (SUM | MAX | MIN | EQUAL) propertyExpression [BY propertyExpression1, ..., propertyExpressionN]
incomeQuantity(store, article) = GROUP SUM inQuantity(document, article) BY store(document), article;
outcomeQuantity(store, article) = GROUP SUM outQuantity(doc, art) BY store(doc), art;

incomeQuantity2(store, article) = GROUP SUM quantity(document, article) IF document IS incomeDocument BY store(document), article;
outcomeQuantity2(store, article) = GROUP SUM quantity(doc, art) IF doc IS outcomeDocument BY store(doc), art;

// CONCAT group property
// GROUP CONCAT propertyExpr, separatorPropertyExpr [BY propertyExpr1, ..., propertyExprN] [ORDER [DESC] orderPropertyExpr1, ..., orderPropertyExprK]
allNames() = GROUP CONCAT name(obj) IF obj IS named, ', ' ORDER DESC name(obj);

// UNIQUE group property
// GROUP UNIQUE propertyExpression [BY propertyExpression1, ..., propertyExpressionN] [WHERE propertyExpression]
nameToCountry(name) = GROUP UNIQUE country BY name(country);


// Union property
// Expression syntax:
// UNION (SUM | MAX | OVERRIDE | XOR | EXCLUSIVE) propertyExpression1, ..., propertyExpressionN
testUnion(store, article) = UNION SUM incomeQuantity(store, article), outcomeQuantity(store, article);

// OR property
// Expression syntax:
// propertyExpression1 OR propertyExpression2
// identical to UNION OVERRIDE

// Recursive property
// Expression syntax:
// RECURSION initPropertyExpression STEP stepPropertyExpression [CYCLES [IMPOSSIBLE]]
// Previous value syntax: $param

// IF THEN ELSE property
// Expression syntax:
// IF propertyExpression0 THEN propertyExpression1 ELSE propertyExpression2
documentTypeString 'Тип документа' (doc) = IF (doc IS incomeDocument) THEN ('Приход' IF doc IS incomeDocument) ELSE ('Расход' IF doc IS outcomeDocument);

// Case property
// Expression syntax:
// CASE
//      WHEN whenPropertyExpression1 THEN thenPropertyExpression1
//      ...
//      WHEN whenPropertyExpressionN THEN thenPropertyExpressionN
//      DEFAULT defaultPropertyExpression
// END
sizeCode 'Размер склада (код)' (ss) = CASE
                                          WHEN ss == storeSize.huge THEN ('HUGE' IF ss IS storeSize)
                                          WHEN ss == storeSize.big THEN ('BIG' IF ss IS storeSize)
                                          WHEN ss == storeSize.medium THEN ('MEDIUM' IF ss IS storeSize)
                                          WHEN ss == storeSize.small THEN ('SMALL' IF ss IS storeSize)
                                          DEFAULT 'UNKNOWN' IF ss IS store
                                      END;
storeSizeCode 'Размер склада (код)' (s) = sizeCode(storeSize(s));

// Partition property
// SUM, PREV partition property
// Expression syntax:
// PARTITION (SUM | PREV) propertyExpression
// [BY propertyExpressionM1, ..., propertyExpressionMN]
// [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
// [WINDOW EXCEPTLAST]
testPartition(store, article) = PARTITION SUM incomeQuantity(store, article) BY store ORDER DESC name(article);

// UNGROUP PROPORTION partition property
// PARTITION UNGROUP propertyObject PROPORTION [STRICT] ROUND(precision) proportionPropertyExpression
// [BY propertyExpressionM1, ..., propertyExpressionMN]
// [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
testAmount(store) = 20.0 IF store IS store;
testData(article) = DATA DOUBLE (article);
testPropPartition(store, article) = PARTITION UNGROUP testAmount PROPORTION STRICT ROUND(2) testData(article) BY store ORDER name(article);

// UNGROUP LIMIT partition property
// PARTITION UNGROUP propertyObject LIMIT [STRICT] limitPropertyExpression
// [BY propertyExpressionM1, ..., propertyExpressionMN]
// [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
testLimitPartition(store, article) = PARTITION UNGROUP testAmount LIMIT STRICT testData(article) BY store ORDER DESC name(article);


// Concatenation/Deconcatenation property
// Expression syntax:
// LIST(propertyExpression1[, ..., propertyExpressionN])
// Access expression syntax with one-base indices:
// concatenatePropertyExpression[2]
ioQuantity(store, article) = LIST(incomeQuantity(store, article), outcomeQuantity(store, article));
onlyIncomeQuantity(store, article) = ioQuantity(store, article)[1];

// Abstract property
// Expression syntax:
// ABSTRACT returnClass ( [paramClass1, ..., paramClassN] ) [EXCLUSIVE]
testAbstract(named) = ABSTRACT INTEGER (namedClass);
// overriding abstract property syntax:
// propertyName(namedParam1, ..., namedParamN) += expression;
testAbstract(named) += 5 AND named IS article;
testAbstract(named) += 6 AND named IS store;

// Abstract action property
// Expression syntax:
// ABSTRACT ACTION ( [param1, ..., paramN] )
testAbstractAction(object) = ABSTRACT ACTION (object);
// overriding abstract action property syntax:
// propertyName(namedParam1, ..., namedParamN) += ACTION actionBody;

testAbstractAction(store) += ACTION MESSAGE 'testing store' AND store IS store;
testAbstractAction(store) += ACTION MESSAGE 'testing store2' AND store IS store;
testAbstractAction(document) += ACTION MESSAGE 'testing document' AND document IS document;
testAbstractAction(document) += ACTION MESSAGE 'testing document2' AND document IS document;

// Formula property
// Expression syntax:
// FORMULA [primitiveType] 'formula text $1 + $2'
sum12 = FORMULA DOUBLE '($1)+($2)*2';
testFormula(store, article) = sum12(incomeQuantity(store, article), outcomeQuantity(store, article));

// Computational expressions
// Priority:
// OR
// AND  IF
// ==  !=
// <  >  <=  >=
// (+) (-)
// +  -
// *  /
// - (unary)
//
// Instances: 5, 5L, 6.35, TRUE, 'some string', staticClass.object, 2011_10_25, 2011_10_25_18:00, NULL, #ff0000, RGB(255, 0, 0)
balanceQuantity(store, article) = incomeQuantity(store, article) - outcomeQuantity(store, article);

foo(store, article) = 5 * incomeQuantity($1, $2) - outcomeQuantity($1, $2);
foo2(store, article) = - outcomeQuantity(store, article) + 5 * incomeQuantity(store, article);
bar = incomeQuantity(store, article) * 5 - 3 - 4 + outcomeQuantity(store, article);
bar2(store, article) = 3.5 * incomeQuantity($1, $2) - (5 + outcomeQuantity($1, $2));
foobar(store, article) = [x*x + y](foo(store, article), bar(store, article));   // lambda-like syntax
baz(store, article) = bar(store, article) > bar2(store, article) IN base;
baz2 = foo(s, a) >= 15 == foo2(s, a) >= 15;

storeIsHuge(store) = storeSize(store) == storeSize.huge;                        // static class instance
storeIsBig(store) = storeSize(store) == storeSize.big;                        // static class instance
storeIsMedium(store) = storeSize(store) == storeSize.medium;                        // static class instance
storeIsSmall(store) = storeSize(store) == storeSize.small;                        // static class instance
storeIsHuge2(store) = (storeSize(store) == storeSize.huge) == TRUE;

documentBalance(document, article) = balanceQuantity(store(document), article);

////////////////ACTION PROPERTIES////////////////
// General Syntax:
// ACTION [(param1, ..., paramN)] actionStatement

// List action
// statement syntax:
// [NEWSESSION [AUTOAPPLY]]  {
//      actionStatement1 | LOCAL name = returnClass ( [paramClass1, ..., paramClassK1] )
//      ...
//      actionStatementN | LOCAL name = returnClass ( [paramClass1, ..., paramClassKN] );
// }
//
// If NEWSESSION is specified than action will be performed in new session.
// If AUTOAPPLY is specified - this new session will be applied by default,
// if not - one should do 'EXEC apply();' explicitly.

// Exec action
// statement syntax:
// EXEC actionPropertyName(propertyExpr1, ..., propertyExprN)
// or
// EXEC [actionPropertyExpr](propertyExpr1, ..., propertyExprN)

// Set action
// statement syntax:
// SET propertyExpressionTo <- propertyExpressionFrom [WHERE conditionalExpression]

// If action
// statement syntax:
// IF propertyExpresson
//      THEN actionStatement1
//     [ELSE actionStatement2]

// For/While action
// statement syntax:
// (FOR | WHILE) propertyExpression [ORDER [DESC] orderExpression1, ..., orderExpressionN] DO actionStatement

// Form action
// statement syntax:
// FORM formName
// [OBJECTS object1 [=mappingExpr1], ..., objectN [=mappinExprN] ]
// [INIT propertyExpr1, ..., propertyExprM]
// [CLASS className]
// [NEWSESSION | MANAGESESSION | OLDSESSION] [DOCKED | MODAL | FULLSCREEN | DOCKED_MODAL] [CHECK]


// Add object action
// statement syntax:
// ADDOBJ className
addObjectActionTest() = ACTION ADDOBJ store;

// Add/Edit form action
// statement syntax:
// (ADDFORM | EDITFORM) [SESSION] className
addActionTest() = ACTION ADDFORM store;
editActionTest(obj) = ACTION EDITFORM store;

// Custom action
// statement syntax:
// CUSTOM 'javaClassName'

// Message action
// statement syntax:
// MESSAGE propertyExpr [ LENGTH n ]
// Default length = 2000

// Change class action
// statement syntax:
// CHANGECLASS object TO className
// built-in or abstract class names are forbidden

// File open/load action
// statement syntax:
// [OPENFILE | LOADFILE] propertyExpression

// Email action
// statement syntax:
// EMAIL
//  [FROM propertyExpression]
//  SUBJECT propertyExpression
//  (TO || CC || BCC) propertyExpression [ (TO || CC || BCC) propertyExpression ...]
//  [(INLINE formName OBJECTS obj1=propertyExpression1, ..., objN=propertyExpressionN) ...]
//  [(ATTACH (PDF, DOCX, HTML, RTF) [NAME propertyExpression] formName OBJECTS obj1=propertyExpression1, ..., objN=propertyExpressionN) ...]

// Confirm action
// statement syntax:
// CONFIRM propertyExpression [LENGTH intValue]

// Request action
// statement syntax:
// REQUEST type (INPUT | [objectName] actionStatement)
// type can be built-in type or OBJECT

// Eval action
// statement syntax:
// EVAL expression

script(doc) = DATA TEXT (document);
evalScript(doc) = ACTION EVAL script(doc);

FORM TestEvalActionForm 'Тест скриптов'
OBJECTS d=document
PROPERTIES(d) store, script, evalScript;


copyStoreNameToArticles 'Скопировать имя склада в имена артиклей' (s) = ACTION(s) {
    SET (name(a) AND a IS article) <- (name(s) AND s IS store);
};

copyStoreNameToArticle 'Добавить имя склада к имени артикля' (s, a) = ACTION(s, a) NEWSESSION AUTOAPPLY {
    SET name(a) <- [FORMULA STRING[20] '$1 || $2'](name(a), name(s));
};

copyStoreNameToArticleError 'Скопировать имя склада в имя артикля (с ошибкой)' (s, a) = ACTION(s, a) NEWSESSION {
    SET name(a) <- name(s);
    EXEC apply();
};

createNewStore 'Добавить большой склад' = ACTION () {
    ADDOBJ store;

    SET sessionObj() <- addedObject();

    SET name(k) IF k == sessionObj() <- [FORMULA STRING[20] '$1 || CAST($2 as char(20))']('New store ', sessionObj());
    SET storeSize(k) IF k == sessionObj() <- storeSize.big;
} TOOLBAR IMAGE 'add.png';

//////////////// TEST PUSHING FOR //////

selCur = SESSION DATA BOOLEAN (document, article);
selAll = SESSION DATA BOOLEAN (document, article);
selArt = SESSION DATA BOOLEAN (article);

testExec = ACTION (document, article) {
    IF quantity(document, article) > 3 THEN
        SET name(article) <- 'More then 3';
}

testPush = ACTION(document) {

    FOR selArt(article) DO // to be pushed
        EXEC testExec(document, article);

    FOR selCur(document, article) ORDER date(document) DO {  // to be pushed
        SET quantity(document, article) <- 5;
    }

    LOCAL i = INTEGER ();
    SET i() <- 0;
    FOR selArt(article) DO // not to be pushed
        SET i() <- i() + 1;
    MESSAGE [FORMULA STRING[20] '$1 || CAST($2 as char(20))']('I= ', i());

    FOR selAll(document2, article) ORDER date(document2) DO { // to be pushed
        SET name(article) <- [FORMULA STRING[20] '$1 || CAST($2 as char(20))']('Article ', quantity(document2, article));
    }

    FOR ADDOBJ article DO {
        MESSAGE name(added);
    }

}

testPush2 = ACTION(document) {

    FOR date(document2) DO { // to be pushed
        SET name(article) <- 'NEW' IF article IS article IF document IS incomeDocument;
    }

    FOR quantity(document2, article) ORDER date(document2) DO { // to be pushed
        SET quantity(document2, article) <- 6;
        SET name(article) <- 'Changed';
    }

    LOCAL i = INTEGER ();
    SET i() <- 0;
    FOR date(document2) DO
        FOR quantity(document2, article) > 3 DO {
            SET i() <- i() + 1;
        }
    MESSAGE [FORMULA STRING[20] '$1 || CAST($2 as char(20))']('I= ', i());

    SET date(document) <- NULL;
}

copy = ACTION(document) {
    FOR quantity(document, article) ADDOBJ article DO {
        SET name(added) <- name(article);
        SET quantity(document, added) <- quantity(document, article);
    }
}

CLASS QuantityString;
@defineAggregation(document, article, QuantityString, quantity);
dateDocumentQuantityString(s) = date(documentQuantityString(s));
storeNameDocumentQuantityString(s) = storeName(documentQuantityString(s));
nameArticleQuantityString(s) = name(articleQuantityString(s));

///////////////CONSTRAINT STATEMENT//////////////
// Syntax:
// CONSTRAINT propertyExpression [CHECKED [BY propertyName1, ..., propertyNameN]] propertyExpression MESSAGE 'message';
CONSTRAINT foo(store, article) > 1000 CHECKED MESSAGE 'ошибка: >1000';


////////////////FOLLOWS STATEMENT////////////////
// Syntax:
// propertyName(param1, ..., paramN) =>
//      propertyExpression1 [RESOLVE (TRUE | FALSE | ALL | NOTHING) [SESSION]],
//      ...
//      propertyExpressionK [RESOLVE (TRUE | FALSE | ALL | NOTHING) [SESSION]];
//foo(store, article) => foo2(store, article) RESOLVE NOTHING;


////////////////WRITEWHEN STATEMENT//////////////
// Syntax:
// propertyName(param1, ..., paramN) <- valuePropertyExpression WHEN changePropertyExpression;

// inQuantity(document, article) <- 15 WHEN CHANGED(foo(store(document), article));


///////////////////EVENT STATEMENT//////////////
// Syntax:
// WHEN expression DO action [ORDER [DESC] expr1, ..., exprN] [SESSION];

constraintAction (store, article) = ACTION (store, article) {
//    EXEC cancel();
    IF foo(store, article) > 300000 THEN {
        MESSAGE name(article);
    }
};

WHEN foo(store,article)>10000 DO EXEC constraintAction(store, article) ORDER name(article) SESSION;

/////////////GLOBAL EVENT STATEMENT//////////////
// Syntax:
// ON (APPLY | SESSION) action;

globalInt() = DATA INTEGER ();
ON SESSION SET globalInt() <- globalInt() (+) 1;

///////////////////ASPECT STATEMENT//////////////
// Syntax:
// BEFORE | AFTER propertyName(param1, ..., paramN) DO action;

BEFORE constraintAction(store, article) DO MESSAGE 'Before Aspect';

//////////////// FORM STATEMENT /////////////////
// Syntax:
// FORM name ['caption'] [TITLE 'title'] [PRINT] [DOCKED | MODAL | FULLSCREEN | DOCKED_MODAL] | EXTEND FORM name
// [(GroupObjects list | TreeGroupObjects list | Properties list | Filters list | Hints list | OrderBy list | filterGroup | dialog form | edit form | list form)]
// ...
// [(GroupObjects list | TreeGroupObjects list | Properties list | Filters list | Hints list | OrderBy list | filterGroup | dialog form | edit form | list form)];
FORM documentArticle 'По документам (caption)' TITLE 'По документам (title)'

// GroupObjects list syntax:
// OBJECTS [alias=] className ['<caption>'] | [groupAlias=] (object1 definition, ..., objectN definition) [REPORTFILE prop(p1, ..., pK)] [INIT | FIXED] [PANEL | HIDE | GRID] [PAGESIZE <int value>],
//         ...
//         [alias=] className ['<caption>'] | [groupAlias=] (object1 definition, ..., objectN definition) [REPORTFILE prop(p1, ..., pK)] [INIT | FIXED] [PANEL | HIDE | GRID] [PAGESIZE <int value>]

// Object definition syntax:
// [alias=] className ['<caption>'] [ON CHANGE action]

OBJECTS document, article

// TreeGroup list syntax:
// TREE [SID] [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] (object1 definition, ..., objectN definition) [PARENT <properties separated with space>],
//            ...
//            [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] (object1 definition, ..., objectN definition) [PARENT <properties separated with space>]

// Property list syntax:
// PROPERTIES [commonOptions] [alias1=]propName1(param1, ..., paramN1) [options1], ..., [aliasK=]propNameK(param1, ..., paramNK) [optionsK]
// or
// PROPERTIES(param1, ..., paramN) [commonOptions] [alias1=]propName1 [options1], ..., [aliasK=]propNameK [optionsK]
// Special properties: SELECTION, OBJVALUE, ADDOBJ, ADDFORM, ADDSESSIONFORM, EDITFORM, EDITSESSIONFORM
// Property option:    [READONLY] [EDITABLE] [SELECTOR] [HINTNOUPDATE] [HINTTABLE] [COLUMNS (<groupObject list>)] [SHOWIF <mappedProperty>] [BACKGROUND <mappedProperty>]
//                     [HEADER <mappedProperty>] [FOOTER <mappedProperty>] [READONLYIF <mappedProperty>] [FORCE PANEL | HIDE | GRID] [TODRAW <groupObject>]
//                     [FOREGROUND <mappedProperty>] [ON (CHANGE | CHANGEWYS) action] [(BEFORE | AFTER) (propertyAlias | <mappedProperty>)] [EVENTID 'id']

PROPERTIES store(document), name(article), testPush(document), testPush2(document), copy(document), date(document), storeName(document) ON CHANGE { REQUEST STRING[50] INPUT; SET storeName(document) <- requestedString(); } , documentTypeString(document)
PROPERTIES quantity(document, article)
PROPERTIES inQuantity(document, article), outQuantity(document, article), documentBalance(document, article), selCur(document, article), selAll(document, article), selArt(article)
PROPERTIES ADDOBJ(document), ADDOBJ(article), testAbstractAction(document)
PROPERTIES globalInt()

// Filters list syntax:
// FILTERS propertyExpression1, ..., propertyExpressionK
FILTERS name(article)

// Events list syntax:
// EVENTS
// ON (INIT | APPLY | OK | CANCEL | CLOSE | DROP) action1,
// ...
// ON (INIT | APPLY | OK | CANCEL | CLOSE | DROP) actionN
EVENTS
    ON CANCEL MESSAGE 'changes were canceled',
    ON APPLY MESSAGE 'form apply message';

// Hints list syntax:
// HINTNOUPDATE | HINTTABLE propertyName1, ..., propertyNameN

// Order list syntax:
// ORDER BY (propertyAlias1 | <mappedProperty1>), ..., (propertyAliasN | <mappedPropertyN>)

showDocumentArticleModalForm 'Показать модальную "По документам"' = ACTION() NEWSESSION {
    ADDOBJ article;

    FOR (k == addedObject()) DO {
        SET name(k) <- 'this is new article';
        BREAK;
    } ELSE
        MESSAGE 'Object wasnt added';

    FORM documentArticle MODAL CHECK;

    IF (formResult() == formResult.ok) THEN {
        MESSAGE 'You pressed "ok"' LENGTH 50;
        MESSAGE [FORMULA STRING[100] '\'You have choosen article \' || $1 || \' and store \' || $2'](name(chosenObject('article')), name(store(chosenObject('document'))));

        FOR (k == chosenObject('article')) DO {
            SET name(k) <- 'THIS article was chosen in modal form';
        };
        FOR (k == store(chosenObject('document'))) DO {
            SET name(k) <- 'Document for THIS store was chosen in modal form';
        };

        RETURN;
    } ELSE IF (formResult() == formResult.close) THEN {
        MESSAGE 'You pressed "close"';
    };
};

i() = SESSION DATA INTEGER ();
testAction 'Показать "По документам" 3 раза' = ACTION() {
    SET i() <- 0;
    WHILE (i() < 3) DO {
        FORM documentArticle MODAL CHECK;
        IF (formResult() == formResult.ok) THEN {
            MESSAGE 'You pressed "ok"' LENGTH 50;
        } ELSE IF (formResult() == formResult.close) THEN {
            MESSAGE 'You pressed "close"';
        };

        SET i() <- i() + 1;
    };
};

FORM testModalForm 'Тестовая форма'
OBJECTS article, i=INTEGER 'Новое имя товара ("Товар %N%"):' FIXED PANEL, store, s=STRING[50] 'Новое имя склада:' FIXED PANEL
PROPERTIES name(article), name(store), OBJVALUE(s), OBJVALUE(i)
;

showTestModalForm 'Показать док-модальную форму' = ACTION() {
    FORM testModalForm NEWSESSION DOCKED_MODAL;
    SET name(k) IF k == chosenObject('store') IF (formResult() == formResult.ok) <- chosenString('s');
    SET name(k) IF k == chosenObject('article') IF (formResult() == formResult.ok) <- [FORMULA STRING[30] '$1 || CAST($2 as char(20))']('Товар ', chosenInteger('i'));
};

remindPasswordEmail 'Выслать пароль на этот email' (u, to) = ACTION EMAIL
//    FROM 'luxsoft@adsl.by'
    SUBJECT [FORMULA STRING[60] '\'Напоминание пароля для \' || $1'](email(u))
    TO (to IF to IS STRING[200])
    CC 'some@someserv.net'
//    BCC 'luxsoft@adsl.by'
    INLINE remindPasswordLetter OBJECTS customUser=(u AS customUser)
    ATTACH PDF
           NAME [FORMULA STRING[60] '\'ATTACH: Напоминание пароля для \' || $1'](email(u))
           remindPasswordLetter OBJECTS customUser=(u AS customUser)
    ;

FORM testEmailForm 'Тестирование EMAIL'
OBJECTS s=STRING[100] 'Email:' FIXED PANEL, u=customUser
PROPERTIES OBJVALUE(s), userLogin(u), userPassword(u), email(u), ADDOBJ(u), remindPasswordEmail(u, s) TODRAW s
;

stime 'Время' (store) = DATA TIME (store) IN base;
sdate 'Дата' (store) = DATA DATE (store) IN base;
sdatetime 'ДатаВремя' (store) = DATA DATETIME (store) IN base;
sword 'Word' (store) = DATA WORDFILE (store) IN base;
simage 'Image' (store) = DATA IMAGEFILE (store) IN base;
spdf 'PDF' (store) = DATA PDFFILE (store) IN base;
scustom 'Custom file' (store) = DATA CUSTOMFILE (store) IN base;
sexcel 'Excel' (store) = DATA EXCELFILE (store) IN base;
scolor 'Color' (store) = DATA COLOR (store) IN base;

testRequestInput 'Тестирование REQUEST input' = ACTION(s) {
    CONFIRM 'Быть или не быть?' LENGTH 100;

    IF (confirmed()) THEN {
        REQUEST COLOR {
            REQUEST COLOR INPUT;
            IF (requestedColor() == #FF0000) THEN {
                SET requestedColor() <- #00FF00;
            }
            SET scolor(s) IF s IS store <- requestedColor();
        }
    } ELSE {
        MESSAGE 'Нет... ';
    }
};

FORM storeArticle 'По складам'
OBJECTS s=store '-Склад-', a=article
PROPERTIES ssel=SELECTION(s), sname=name(s), obja=OBJVALUE(a), aname=name(a)
PROPERTIES TODRAW s FORCE PANEL copyStoreNameToArticles(s), copyStoreNameToArticle(s, a), copyStoreNameToArticleError(s, a), createNewStore(), showDocumentArticleModalForm(), showTestModalForm() DRAWTOTOOLBAR, testRequestInput(s) DRAWTOTOOLBAR
PROPERTIES(s, a) SHOWIF storeIsHuge(s) incomeQuantity2, outcomeQuantity2
PROPERTIES(s) storeSizeName, ssc1=storeSizeCode, storeIsHuge, stime, sdate, sdatetime, ssi=Features.simage, spdf, scustom, sexcel, testAbstractAction, editActionTest
PROPERTIES(s, a) incomeQuantity, outcomeQuantity, foo, foo2 SHOWIF storeIsHuge(s), bar, foobar HEADER name(a), bar2, baz, baz2, balanceQuantity, testUnion HEADER name(s), testPartition, testFormula
FILTERGROUP filters1
    FILTER 'Показывать только огромные склады' 'F10' storeIsHuge(s)
ORDER BY name(s) DESC, foo, ssel
;

EXTEND FORM storeArticle
PROPERTIES(s) ssw=sword AFTER ssi
;

EXTEND FORM storeArticle
PROPERTIES(s) scolor AFTER ssw
;

FORM editStore 'Редактирование склада'
OBJECTS s=store FIXED PANEL
PROPERTIES(s) name, storeSizeName, storeIsHuge, storeIsHuge2
// To use this form as EDIT\DIALOG\LIST form for some class (for ex. store)
// Use this syntax:
//(EDIT | DIALOG | LIST) <className> OBJECT <objectName>
EDIT store OBJECT s
;

dateProp(store) = 2007_12_01 AND store IS store;
//dateTimeProp(store) = 2007_12_01_18:00 AND store IS store;
variableDateTime(store) = DATA DATETIME (store);

FORM TestDataPropForm 'Тест дат'
OBJECTS store
PROPERTIES(store) dateProp, variableDateTime
//PROPERTIES dateTimeProp()
;

colorizeMatchingStoreSize (s, ss) = scolor(s) IF storeSize(s) == ss;
storeSizeString (s, ss) = DATA STRING[10] (store, storeSize);
storeSizeHeader (s, ss) = UNION OVERRIDE name(ss) IF s IS store AND ss IS storeSize AND ss!=storeSize.small, storeSizeString(s, ss);

FORM TestColumnGroupObjects 'Тест групп в колонках'
OBJECTS ss=storeSize, s=store
PROPERTIES name(ss), sizeCode(ss)
PROPERTIES OBJVALUE(s), name(s), scolor(s), storeSizeCode(s)
PROPERTIES storeSizeString(s, ss) COLUMNS (ss) HEADER sizeCode(ss) BACKGROUND colorizeMatchingStoreSize(s, ss) HEADER storeSizeHeader(s, ss);

colorizeElementWithNumberGreaterFour(element) = #5555ff IF numberNavigatorElement(element) > 4;

FORM TestTree 'Тест дерева (формы)'
TREE forms e=navigatorElement PARENT parentNavigatorElement
PROPERTIES(e) navigatorElementCaption, navigatorElementSID, numberNavigatorElement BACKGROUND colorizeElementWithNumberGreaterFour(e), permitForm, forbidForm;

DESIGN TestTree FROM DEFAULT {
    forms.tree.box {
        fillHorizontal = 1;
        fillVertical = 1;
    }
}

FORM TestAggr 'Тест агрегаций'
OBJECTS s=QuantityString
PROPERTIES dateDocumentQuantityString(s), storeNameDocumentQuantityString(s), nameArticleQuantityString(s), delete(s);

FORM TestHeaders 'Тест заголовков'
OBJECTS s=store, a=article
PROPERTIES(s) name, storeSizeCode
PROPERTIES(a) OBJVALUE, name
PROPERTIES(s, a) SHOWIF storeIsHuge(s) incomeQuantity2, outcomeQuantity2
PROPERTIES(s, a) incomeQuantity, outcomeQuantity, foobar HEADER name(a), testUnion HEADER name(s)
FILTERGROUP filters1
    FILTER 'Показывать только огромные склады' 'F10' storeIsHuge(s)
;

FORM TestHotkeys 'Тест хоткеев'
OBJECTS s=store, a=article
PROPERTIES(s) ns=name, storeSizeCode
PROPERTIES(a) OBJVALUE, na=name
PROPERTIES(s, a) incomeQuantity, outcomeQuantity, foobar, testUnion
FILTERGROUP filters1
    FILTER 'Показывать только огромные склады' 'F7' storeIsHuge(s)
FILTERGROUP filters2
    FILTER 'Показывать только огромные склады' 'F3' storeIsHuge(s)
    FILTER 'Показывать только большие склады' 'F9' storeIsBig(s)
    FILTER 'Показывать только средние склады' 'F10' storeIsMedium(s)
    FILTER 'Показывать только маленькие склады' 'F11' storeIsSmall(s)
;

DESIGN TestHotkeys FROM DEFAULT {
    PROPERTY(ns) {
        editKey = 'F4';
    }

    PROPERTY(na) {
        editKey = 'F5';
    }
}
//////////////// INDEX STATEMENT //////////////////
// Syntax:
// INDEX propertyName1 [, ..., propertyNameN];
INDEX quantity, store;


//////////////// WINDOW STATEMENT /////////////////
// Add new window statement
// Syntax:
// WINDOW (MENU | PANEL | TREE | TOOLBAR) <name> '<caption>' [ option [, option ...] ]
// option ::=   HIDETITLE |
//              HIDESCROLLBARS |
//              DRAWROOT |
//              (VERTICAL | HORIZONTAL) |
//              (LEFT | RIGHT | TOP | BOTTOM) |
//              POSITION(x, y, w, h) |
//              HALIGN( LEFT | CENTER | RIGHT ) |
//              VALIGN( TOP | CENTER | BOTTOM ) |
//              TEXTHALIGN( LEFT | CENTER | RIGHT ) |
//              TEXTVALIGN( TOP | CENTER | BOTTOM )
WINDOW TOOLBAR mainToolbar 'Навигатор' VERTICAL POSITION(0, 0, 20, 99) HIDETITLE HALIGN(CENTER) TEXTVALIGN(BOTTOM) TEXTHALIGN(CENTER);
WINDOW TOOLBAR leftToolbar 'Список' VERTICAL POSITION(20, 0, 20, 70);
WINDOW TREE objectsWindow 'Объекты' POSITION(20, 70, 20, 29) DRAWROOT;

//Hide window
HIDE WINDOW System.log;
HIDE WINDOW System.relevantForms;
HIDE WINDOW relevantClassForms;

//////////////// NAVIGATOR STATEMENT /////////////////
//настройка навигатора
NAVIGATOR {
    // чтобы добавить существующий элемент в другой элемент используется команда следующего вида
    // ADD <имя> ['<новый заголовок>'] [(IN | AFTER | BEFORE) <имя>] [TO <новое окно>];
    // при этом по умолчанию он будет добавлен в элемент текущей области видимости
    // (при использовании прямо внутри NAVIGATOR - он будет добавлен в baseElement)
    //
    // для создания нового элемента используется команда:
    // NEW <имя> '<заголовок>' [(IN | AFTER | BEFORE) <имя>] [TO <имя окна>] [ACTION <имя экшена>];

    NEW element1 'Element 1' AFTER userPolicyForm;

    NEW element2 'Element 2' BEFORE userPolicyForm;
    ADD storeArticle IN element2;

    NEW outer 'Outer element' IN element1 {
        ADD dictionaries 'Dictionaries' {
            NEW underForm 'under form element';
        }

        ADD element2;
    }

    //при создании элемента можно указать окно для него
    NEW testNavigators '-Тестовые навигаторы-' AFTER adminForm TO mainToolbar;

    // также можно просто настраивать существующий элемент без его перемещения
    testNavigators 'Тестовые навигаторы' {
        ADD element1 {
            //...
        }
        ADD element2;
        ADD underForm;
        ADD editStore;
        ADD testModalForm;

        //если задано имя действия, то создаться элемент для запуска этого действия
        NEW testNavigatorAction 'Показать "По документам" 3 раза' ACTION testAction;
    }
    // так можно отдельно настроить окно, в которое будет рисоваться элемент
    root TO mainToolbar;
    testNavigators TO leftToolbar;
    administration TO leftToolbar;
    account TO leftToolbar;
    objects TO objectsWindow;

    ADD dictionaries 'Словари' AFTER daysOffForm;
    ADD storeArticle;
    ADD documentArticle;
    ADD TestDataPropForm;
    ADD TestColumnGroupObjects;
    ADD TestTree;
    ADD TestAggr;
    ADD TestHeaders;
    ADD TestHotkeys;
    ADD TestEvalActionForm;
}

//////////////// DESIGN STATEMENT /////////////////
//При создании дизайна по умолчанию создаётся набор контейнеров и компонентов с определёнными именами
//
//Соответсвие между вызовами в Java и именами доступными в настройке дизайна показаны ниже
//(также указан тип объекта - контейнер или компонент):
//
//getMainContainer => CONTAINER main
//
//getTreeContainer => CONTAINER treeName.tree.box
//get(TreeGroupEntity) => COMPONENT treeName.tree
//
//getGroupObjectContainer => CONTAINER groupName.box
//getPanelContainer => CONTAINER groupName.panel
//get(GroupObjectEntity)
//    .grid => COMPONENT groupName.grid
//    .showType => COMPONENT groupName.showType
//getGridContainer => CONTAINER groupName.grid.box
//getControlsContainer => CONTAINER groupName.controls
//getFilterContainer => CONTAINER groupName.filters
//
//getGroupPropertyContainer(AbstractGroup)
//     для групп данного модуля =>  CONTAINER groupName.propGroupName
//     для групп других модулей =>  CONTAINER groupName.moduleName_propGroupName
//
//get(ObjectEntity)
//    .classChooser => COMPONENT objectName.classChooser
//
//getRegularFilterGroup => COMPONENT filters.filterName
//
//get*Function => COMPONENT functions.*
//getFormButtonContainer=> CONTAINER functions.box
//
//get(PropertyDrawEntity) => COMPONENT PROPERTY(propSelector(...))


DESIGN storeArticle FROM DEFAULT {
    // Чтобы добавить контейнер в другой контейнер используется команда '(ADD | NEW ) <имя> [(IN | BEFORE | AFTER) <имя2>]'.
    // При использовании NEW контейнер будет создан, если компонент с таким именем уже существовал, то будет ошибка.
    // При этом по умолчанию он будет добавлен в контейнер текущей области видимости
    // (при использовании прямо внутри DESIGN - он будет добавлен в main контейнер)
    NEW newContainer {
        // будет добавлен в newContainer, т.к. находится в его области видимости
        NEW child1 {
            // будет добавлен в child1, т.к. находится в его области видимости
            NEW child11;
        }

        // будет добавлен в child11, т.к. явно указано куда добавлять
        NEW child2 IN child11;

        // будет добавлен в child1, перед child11, т.к. это явно указано
        NEW child3 BEFORE child11;

        // будет добавлен в child1, после child11, т.к. это явно указано
        NEW child4 AFTER child11;

        NEW child5;

        // для задания intersections используется конструкция вида:
        // POSITION <имя1> (TO THE LEFT | TO THE RIGHT | TO THE BOTTOM | TO THE RIGHTBOTTOM | TO NOT INTERSECT) [<имя2>]
        // например следующая команда добавит intersection для расположения child1 слева от child5;
        POSITION child1 TO THE LEFT child5;

        // при этом компоненты должны быть в одном контейнере, т.е. следующая команда выдаст ошибку:
        // POSITION child2 TO THE LEFT child3;

        ADD child5 {
            // если второе имя емя не указано, то будет использован компонент из данной области видимости
            // т.е. в данном месте команда 'POSITION child1 TO NOT INTERSECT child5' равносильна просто:
            POSITION child1 TO NOT INTERSECT;
        }
    }
    // для удаления компонента используется команда REMOVE <имя> [CASCADE];
    // если CASCADE не указано, то удалится только сам контейнер,
    // а вложенные контейнеры будут доступны для дальнейшей вставки в другие места обычным образом
    // если же CASCADE указано, то удалится сам контейнер со всем вложенными

    // REMOVE newContainer;
    REMOVE newContainer CASCADE;

    // для настройки свойств используется конструкция вида
    //  <имя свойства> = <значение>;
    // при этом будет изменено свойство объекта в текущей области видимости
    // для верхней области видимости будет изменяться сама форма
    //
    // все названия доступных свойств объектов совпадают с таковыми в Java
    // кроме того вложенные свойства constraints.* и component.design.* доступны напрямую
    // например в Java: design.overridePageWidth = 3000;
    // соотвествует
    overridePageWidth = 3000;

    // для формы есть одно исключение для единообразия с другими объектами - вместо caption используется title
    // т.е. в Java: richDesign.caption = "Справочник складов"; соотвествует
    title = 'Справочник складов';


    // для того, чтобы просто настроить свойства объекта без добавления его в текущий контейнер,
    // используется следующая конструкция
    main {
        title = 'Главный контейнер';

        ADD functions.box BEFORE s.box;

        a.box {
            title = 'Артикль';
            fillHorizontal = 2.5;
        }

        s.box {
            // в Java: someComponent.constraints.fillVertical = 0.3; соответсвует
            fillVertical = 0.2;

            //здесь всё так же можно применять команды ADD, POSITION и т.д.
            NEW child1 {
                // так контейнер будет отображаться в виде табов
                // соответсвует в Java: container.type = ContainerType.TABBED_PANE;
                type = TABBED;
                // а так - в виде SplitPane'а: type = SPLITV
                //                             type = SPLITH

                NEW child2;

                // настраивать объекты можно в любой области видимости - это ни на что не повлияет
                s.box {
                    fillVertical = 0;
                }
            }
            REMOVE child1 CASCADE;
        }
    }

    //для настройки GroupObjectView используется следующая конструкция
    GROUP(s) {
        tableRowsCount = 10;
        needVerticalScroll = FALSE;
    }


    //для доступа к компоненту свойства (PropertyDrawView) используется следующая конструкция
    //здесь просто выберется 1й компонент для конкретного свойства
    PROPERTY(bar) { caption = 'Барр'; }

    //здесь - компонент для свойства с определённым мэппингом
    PROPERTY(storeSizeName(s)) { caption = 'Имя размера склада'; }

    PROPERTY(foo(s, a)) {
        focusable = FALSE;
        panelLabelAbove = TRUE;
        caption = 'This is foo\'s caption!';
    }

    // настройка некоторых других свойств
//    PROPERTY(name(a)) {
    PROPERTY(aname) {
        // настройка свойств, соответсвующих клавишам
        showEditKey = TRUE;
        editKey = 'ctrl F6';
        caption = 'Имя (a)';

        // шрифт
        headerFont = 'Tahoma bold italic 15';
        headerFont = 'Tahoma bold 13';
        headerFont = 'Tahoma 12';
    }

    NEW setupEx {
        // Dimension
        minimumSize = (100, 200);

        // constraints.childConstraints
        childConstraints = TO THE LEFT;
        childConstraints = TO THE RIGHT;
        childConstraints = TO NOT INTERSECT;

        //Insets
        insetsInside = ( -100, -200, 300, 400);
    }
    REMOVE setupEx;

    s.toolbar {
//        visible = FALSE;
        showPrintGroupButton = FALSE;
        showPrintGroupXlsButton = FALSE;
    }
}

//////////////// METACODE STATEMENT /////////////
// Syntax:
// META codeName([param1, ..., paramN]) metacode END
//
// Metacode usage syntax:
// @codeName([[param1], ..., [paramN]]);
//
// concatenation operator: ##
// concatenation capitalize operator: ###

META metaCodeSample(name)
    CLASS name##Class;
    GROUP name ### group;
END

META metaCodeSample(name, name2)
    CLASS name##Class##name2;
END

@metaCodeSample(testName1);
@metaCodeSample(testName2);

@metaCodeSample(testName1, testName2);

//////////////// TABLE STATEMENT ////////////////
// Syntax:
// TABLE name(className1, ..., classNameN);
TABLE documentArticle(document, article);

