MODULE PriceList;

REQUIRE System, Document, Numerator, Stock, Barcode;

// --------------------------- Ценовые группы -------------------------------------//

CLASS ABSTRACT priceGroup 'Ценовая группа' : named;

priceGroupSku = ABSTRACT priceGroup (sku) PERSISTENT;

@defineHierarchyAbstract(priceGroup);

// --------------------------- Виды цен ------------------------- //

CLASS ABSTRACT priceListType 'Вид цены' : named;
TABLE priceListType(priceListType);

pricePriceListTypeSkuStockDateTime 'Цена' = ABSTRACT NUMERIC[14,2] (priceListType, sku, stock, DATETIME);
pricePriceListTypeBatchStockDateTime 'Цена' = ABSTRACT NUMERIC[14,2] (priceListType, batch, stock, DATETIME);
includeVATPriceListType 'Цена с НДС' = ABSTRACT BOOLEAN (priceListType);

prevPricePriceListTypeSkuStockDateTime 'Цена (пред.)' (type, sku, stock, dateTime) = PREV(pricePriceListTypeSkuStockDateTime(type, sku, stock, dateTime));
prevPricePriceListTypeBatchStockDateTime 'Цена (пред.)' (type, batch, stock, dateTime) = PREV(pricePriceListTypeBatchStockDateTime(type, batch, stock, dateTime));

@defineDocumentAbstractHeaderCurrency(priceListType);

CLASS ABSTRACT basePriceListType 'Базовый вид цены' : priceListType;

priceBasePriceListTypeSkuStockDateTime (type, sku, stock, dateTime) = ABSTRACT NUMERIC[14,3] (basePriceListType, sku, stock, DATETIME) EXCLUSIVE;
priceBasePriceListTypeBatchStockDateTime (type, sku, stock, dateTime) = ABSTRACT NUMERIC[14,3] (basePriceListType, batch, stock, DATETIME) EXCLUSIVE;
includeVATBasePriceListType 'Цена с НДС' = ABSTRACT BOOLEAN (basePriceListType);

pricePriceListTypeSkuStockDateTime(type, sku, stock, dateTime) += priceBasePriceListTypeSkuStockDateTime(type, sku, stock, dateTime);
pricePriceListTypeBatchStockDateTime(type, batch, stock, dateTime) += priceBasePriceListTypeBatchStockDateTime(type, batch, stock, dateTime);
includeVATPriceListType(type) += includeVATBasePriceListType(type);

// --------------------------- Системные виды цен ------------------------- //
CLASS STATIC systemPriceListType 'Системный вид цены' : basePriceListType;

priceSystemPriceListTypeSkuStockDateTime (type, sku, stock, dateTime) = ABSTRACT NUMERIC[14,3] (systemPriceListType, sku, stock, DATETIME) EXCLUSIVE;
priceSystemPriceListTypeBatchStockDateTime (type, sku, stock, dateTime) = ABSTRACT NUMERIC[14,3] (systemPriceListType, batch, stock, DATETIME) EXCLUSIVE;
includeVATSystemPriceListType 'Цена с НДС' = DATA BOOLEAN (systemPriceListType);

priceBasePriceListTypeSkuStockDateTime(type, sku, stock, dateTime) += priceSystemPriceListTypeSkuStockDateTime(type, sku, stock, dateTime);
priceBasePriceListTypeBatchStockDateTime(type, batch, stock, dateTime) += priceSystemPriceListTypeBatchStockDateTime(type, batch, stock, dateTime);
includeVATBasePriceListType(type) += includeVATSystemPriceListType(type);

// -------------------------- Учетная цена ---------------------- //

EXTEND CLASS systemPriceListType { stockPriceListType 'Учетная' }
priceSystemPriceListTypeSkuStockDateTime (type, sku, stock, dateTime) += priceSkuStockDateTime(sku, stock, dateTime) AND type == systemPriceListType.stockPriceListType;
priceSystemPriceListTypeBatchStockDateTime (type, batch, stock, dateTime) += priceBatchStockDateTime(batch, stock, dateTime) AND type == systemPriceListType.stockPriceListType;

// ------------------------------------- Виды цен, формируемые ledger'ами ----------- //

CLASS ABSTRACT ledgerPriceListType 'Регистровый вид цены' : basePriceListType;

CLASS ABSTRACT priceListLedger;
TABLE priceListLedger(priceListLedger);

fromDateTimePriceListLedger = ABSTRACT DATETIME (priceListLedger) PERSISTENT INDEXED;
toDateTimePriceListLedger = ABSTRACT DATETIME (priceListLedger) PERSISTENT INDEXED;

skuPriceListLedger = ABSTRACT sku (priceListLedger) PERSISTENT INDEXED;

descriptionPriceListLedger = ABSTRACT STRING[200] (priceListLedger) PERSISTENT;

TABLE priceListLedgerLedgerPriceListType(priceListLedger, ledgerPriceListType);
pricePriceListLedgerLedgerPriceListType = ABSTRACT NUMERIC[14,2] (priceListLedger, ledgerPriceListType) EXCLUSIVE PERSISTENT;

TABLE priceListLedgerStock(priceListLedger, stock);
inPriceListLedgerStock (ledger, stock) = ABSTRACT BOOLEAN (priceListLedger, stock) PERSISTENT;

orderPriceListLedger(ledger) = LIST(fromDateTimePriceListLedger(ledger), ledger) PERSISTENT;

TABLE priceListLedgerLedgerPriceListTypeStock (priceListLedger, ledgerPriceListType, stock);
orderPriceListLedgerLedgerPriceListTypeStock(ledger, type, stock) =
    orderPriceListLedger(ledger) IF pricePriceListLedgerLedgerPriceListType(ledger, type) AND inPriceListLedgerStock(ledger, stock) PERSISTENT INDEXED;

concatLedgerPriceListTypeSkuStockDateTime(type, sku, stock, dateTime) =
    GROUP MAX orderPriceListLedgerLedgerPriceListTypeStock(ledger, type, stock)
              IF fromDateTimePriceListLedger(ledger) < (dateTimeIn AS DATETIME) AND NOT toDateTimePriceListLedger(ledger) <= (dateTimeIn AS DATETIME)
          BY type, skuPriceListLedger(ledger), stock, dateTimeIn;
priceListLedgerLedgerPriceListTypeSkuStockDateTime(type, sku, stock, dateTime) =
    concatLedgerPriceListTypeSkuStockDateTime(type, sku, stock, dateTime)[2];

priceLedgerPriceListTypeSkuStockDateTime 'Цена' (type, sku, stock, dateTime) =
    pricePriceListLedgerLedgerPriceListType(priceListLedgerLedgerPriceListTypeSkuStockDateTime(type, sku, stock, dateTime), type);
priceLedgerPriceListTypeBatchStockDateTime 'Цена' (type, batch, stock, dateTime) =
    priceLedgerPriceListTypeSkuStockDateTime(type, skuBatch(batch), stock, dateTime);

descriptionLedgerPriceListTypeSkuStockDateTime 'Описание' (type, sku, stock, dateTime) =
    descriptionPriceListLedger(priceListLedgerLedgerPriceListTypeSkuStockDateTime(type, sku, stock, dateTime));
descriptionLedgerPriceListTypeBatchStockDateTime 'Описание' (type, batch, stock, dateTime) =
    descriptionPriceListLedger(priceListLedgerLedgerPriceListTypeSkuStockDateTime(type, skuBatch(batch), stock, dateTime));

includeVATLedgerPriceListType 'Цена с НДС' = DATA BOOLEAN (ledgerPriceListType);

priceBasePriceListTypeSkuStockDateTime(type, sku, stock, dateTime) += priceLedgerPriceListTypeSkuStockDateTime(type, sku, stock, dateTime);
priceBasePriceListTypeBatchStockDateTime(type, batch, stock, dateTime) += priceLedgerPriceListTypeBatchStockDateTime(type, batch, stock, dateTime);

includeVATBasePriceListType(type) += includeVATLedgerPriceListType(type);

// --------------------------- Системные виды цен, на основе Ledger'ов ------------------ //

CLASS STATIC systemLedgerPriceListType 'Системный вид цены (регистр)' : ledgerPriceListType;

// --------------------------- Пользовательские виды цен ------------------------- //

CLASS dataPriceListType 'Пользовательский вид цены' : ledgerPriceListType;
@defineDocumentHeaderCurrency(dataPriceListType);
currencyPriceListType(dataPriceListType) += currencyDataPriceListType(dataPriceListType);

CLASS ABSTRACT priceList 'Прайс';
CLASS ABSTRACT priceListDetail 'Строка прайса';

CLASS userPriceList 'Прайс (польз.)' : priceList, historyObject, numeratedObject;
CLASS userPriceListDetail 'Строка прайса (польз.)' : priceListDetail;
CLASS userPriceListPosted 'Закрытый прайс (польз.)' : userPriceList, postedObject;

@defineDocumentInterface(priceList);

@defineDocumentInterfaceTimePrefix(priceList, from, ' c');
@defineDocumentInterfaceTimePrefix(priceList, to, ' по');

@defineDocumentInterfaceNumber(priceList);
@defineNumeratedObjectDefault(priceList, 'Нумератор для прайсов', 'ПЛ');

//@defineDocumentInterfaceDataStock(priceList, stock, 'Склад');
@defineDocumentInterfacePosted(priceList);

@defineDocumentInterfaceDescription(priceList, 'Прайс');

@defineDocumentInterfaceCurrency(priceList);
//@deriveDocumentCurrency(userPriceList, dataPriceListType);

@defineDocumentInterfaceDetailSku(priceList, sku);
//@defineDocumentInterfaceDetailPrice(priceList);

//castPriceList =
//    FORMULA STRING[100] '\'Прайс №\' || CAST($1 AS TEXT) || \' от \' || CAST($2 AS TEXT)';
//descriptionPriceList 'Описание' (priceList) =
//    castPriceList(seriesNumberObject(priceList), datePriceList(priceList)) IN documentPrmGroup;

toDateUserPriceList(userPriceList) <- NULL WHEN ASSIGNED(userPriceList IS userPriceList);
toTimeUserPriceList(userPriceList) <- NULL WHEN ASSIGNED(userPriceList IS userPriceList);

pricePriceListDetailDataPriceListType 'Цена' = ABSTRACT NUMERIC[14,2] (priceListDetail, dataPriceListType) PERSISTENT;
priceUserPriceListDetailDataPriceListType 'Цена' = DATA NUMERIC[14,2] (priceListDetail, dataPriceListType);
pricePriceListDetailDataPriceListType (priceListDetail, dataPriceListType) += priceUserPriceListDetailDataPriceListType(priceListDetail, dataPriceListType);

//@defineAddDetailDialogSkuStock(userPriceList, sku, stock, dialogSku);

TABLE priceListDataPriceListType (priceList, dataPriceListType);
TABLE priceListDetailDataPriceListType (priceListDetail, dataPriceListType);

inPriceListPriceListType 'Отм' = ABSTRACT BOOLEAN (priceList, dataPriceListType) PERSISTENT;
inUserPriceListPriceListType 'Отм' = DATA BOOLEAN (userPriceList, dataPriceListType);
inPriceListPriceListType (priceList, dataPriceListType) += inUserPriceListPriceListType(priceList, dataPriceListType);

priceListTypesPriceList 'Цены' (priceList) = GROUP CONCAT name(priceListType) IF inPriceListPriceListType(priceList, priceListType) , ', '
                                               BY priceList
                                               ORDER priceListType MINCHARWIDTH 50 PERSISTENT;

inPriceListDetailPriceListType (detail, dataPriceListType) = inPriceListPriceListType(priceListPriceListDetail(detail), dataPriceListType) PERSISTENT;

pricePriceListDetailDataPriceListType(detail, dataPriceListType) => inPriceListDetailPriceListType (detail, dataPriceListType) RESOLVE FALSE;

inPriceList 'Отм' = ABSTRACT BOOLEAN (priceList) PERSISTENT;
inUserPriceList 'Отм' = DATA BOOLEAN (userPriceList);
inUserPriceList(userPriceList) <- TRUE WHEN ASSIGNED(userPriceList IS userPriceList);
inPriceList (priceList) += inUserPriceList(priceList);

TABLE priceListStockGroup(priceList, stockGroup);
inPriceListStockGroup 'Отм' = ABSTRACT BOOLEAN (priceList, stockGroup) PERSISTENT;
inUserPriceListStockGroup 'Отм' = DATA BOOLEAN (userPriceList, stockGroup);
inPriceListStockGroup (priceList, stockGroup) += inUserPriceListStockGroup(priceList, stockGroup);

TABLE priceListStock(priceList, stock);
inPriceListStock 'Отм' = ABSTRACT BOOLEAN (priceList, stock) PERSISTENT;
inUserPriceListStock 'Отм' = DATA BOOLEAN (userPriceList, stock);
inPriceListStock (priceList, stock) += inUserPriceListStock(priceList, stock);

TABLE priceListDetailStock(priceListDetail, stock);
dataPriceListDetailStock (detail, stock) = inPriceListStock(priceListPriceListDetail(detail), stock) PERSISTENT;

levelParentPriceListStockGroup (priceList, stockGroup) = GROUP MIN levelStockGroupStockGroup(stockGroup, parent) IF inPriceListStockGroup(priceList, parent)
                                                               BY priceList, stockGroup PERSISTENT;
nearestParentStockGroup (priceList, stockGroup) = stockGroupStockGroupLevel(stockGroup, levelParentPriceListStockGroup(priceList, stockGroup));
nearestInPriceListStockGroup (priceList, stockGroup) =
    inPriceListStockGroup(priceList, nearestParentStockGroup(priceList, stockGroup));

inPriceListStockGroupOver 'Отм' (priceList, stockGroup) =
    UNION OVERRIDE inPriceList(priceList) AND stockGroup IS stockGroup,
                   nearestInPriceListStockGroup(priceList, stockGroup),
                   inPriceListStockGroup(priceList, stockGroup);

inPriceListStockOver 'Отм' (priceList, stock) =
    UNION OVERRIDE inPriceList(priceList) AND stock IS stock,
                   nearestInPriceListStockGroup(priceList, stockGroupStock(stock)),
                   inPriceListStock(priceList, stock);

stocksPriceList 'Склады' (priceList) = GROUP CONCAT name(stock) IF inPriceListStockOver(priceList, stock) , ', '
                                       BY priceList
                                       ORDER stock MINCHARWIDTH 100 PERSISTENT;

currentPricePriceListDetailDataPriceListTypeStock 'Действующая цена' (priceListDetail, dataPriceListType, stock) =
    prevPricePriceListTypeSkuStockDateTime(dataPriceListType, skuPriceListDetail(priceListDetail), stock, fromDateTimePriceListDetail(priceListDetail));

currentPriceSkuPriceListDataPriceListTypeStock 'Действующая цена' (sku, priceList, dataPriceListType, stock) =
    prevPricePriceListTypeSkuStockDateTime(dataPriceListType, sku, stock, fromDateTimePriceList(priceList));

markUpPricePriceListDetailDataPriceListTypeStock 'Надбавка, %' (priceListDetail, dataPriceListType, stock) =
    pricePriceListDetailDataPriceListType(priceListDetail, dataPriceListType) * 100.0 /
    currentPricePriceListDetailDataPriceListTypeStock (priceListDetail, dataPriceListType, stock) - 100.0;

extendNameDataPriceListType (dataPriceListType) =
    [FORMULA STRING[50]  ' \'Действующая \' || CAST($1 AS TEXT) || \' цена \''](
    name(dataPriceListType)) MINCHARWIDTH 30 MAXCHARWIDTH 50;

extendNameMarkUpDataPriceListType (dataPriceListType) =
    [FORMULA STRING[50]  'CAST($1 AS TEXT) || \' наценка \''](
    name(dataPriceListType)) MINCHARWIDTH 30 MAXCHARWIDTH 50;

inStockGroupStock (stockGroup, stock) = UNION OVERRIDE stock IS stock AND NOT stockGroup IS stockGroup, isParentStockGroupStock(stockGroup, stock);

detailSkuUserPriceList(sku, price) = GROUP SUM 1 IF sku == skuUserPriceListDetail(detail) AND price == userPriceListUserPriceListDetail(detail)
                                           BY skuUserPriceListDetail(detail), userPriceListUserPriceListDetail(detail);

inSkuUserPriceList 'Отм.' (sku, price) = TRUE IF detailSkuUserPriceList(sku, price);

changeInSkuUserPriceList = ACTION (sku, price) {
    REQUEST BOOLEAN INPUT;
    IF TRUE AND NOT requestedLogical() THEN {
        IF detailSkuUserPriceList(sku, price) THEN {
            FOR sku == skuUserPriceListDetail(detail) AND price == userPriceListUserPriceListDetail(detail) DO {
                EXEC delete(detail);
            }
        }
    } ELSE {
        IF requestedLogical() THEN {
            FOR ADDOBJ d = userPriceListDetail DO {
               SET userPriceListUserPriceListDetail(d) <- price;
               SET skuUserPriceListDetail(d) <- sku;
            }
        }
    }
}

isSelectedPriceListDetail 'Отм' = SESSION DATA BOOLEAN (priceListDetail);
sumSelectedPriceList (priceList) =
    GROUP SUM 1 IF isSelectedPriceListDetail(priceListDetail)
          BY priceListPriceListDetail(priceListDetail);

FORM chooseMarkUpSkuUserPriceList 'Наценка'

    OBJECTS p = userPriceList FIXED PANEL

    OBJECTS t = dataPriceListType FIXED PANEL
    PROPERTIES(t) SELECTOR name

    OBJECTS n = NUMERIC[20,7] FIXED PANEL
    PROPERTIES(n) objValue = OBJVALUE

    FILTERS inPriceListPriceListType(p, t)
;

DESIGN chooseMarkUpSkuUserPriceList FROM DEFAULT {

    REMOVE p.box;
    NEW topContainer {
        childConstraints = TO THE RIGHT;
        ADD PROPERTY(name(t));
        ADD PROPERTY(objValue);
        PROPERTY(objValue){caption = 'Наценка, %';}
    }
    ADD functions.box;
}

sessionDataPriceListType 'Вид цены' = SESSION DATA dataPriceListType();

changeMarkUpSkuUserPriceList 'Изменить наценку' = ACTION (userPriceList, dataPriceListType, stock){

    FORM chooseMarkUpSkuUserPriceList OBJECTS p = userPriceList, t = dataPriceListType MODAL;
    IF formResult() == formResult.ok THEN {
        IF TRUE AND NOT sumSelectedPriceList(userPriceList) THEN MESSAGE 'Выберите хотя бы одну позицию' ELSE
        SET pricePriceListDetailDataPriceListType(detail, t) <-
                currentPricePriceListDetailDataPriceListTypeStock(detail, t, stock) * (chosenNumeric('n') + 100.0) / 100.0
                WHERE isSelectedPriceListDetail(detail) AND userPriceListUserPriceListDetail(detail) == userPriceList AND t == chosenObject('t');
    }
}

FORM userPriceList 'Прайс'
    TREE skuTree sk = skuGroup PARENT parentSkuGroup
    PROPERTIES READONLY skuTreeName = name(sk)
    ORDER BY skuTreeName

    OBJECTS p = userPriceList FIXED PANEL
    PROPERTIES(p) objectClassName, nameNumeratorObject, numberObject, seriesObject,
                  dateUserPriceList, timeUserPriceList,
                  fromDateUserPriceList, fromTimeUserPriceList, toDateUserPriceList, toTimeUserPriceList,
                  nameCurrencyUserPriceList, noteUserPriceList, includeVATLedgerPriceListType

    OBJECTS t = dataPriceListType
    PROPERTIES(t) READONLY name
    PROPERTIES(p, t) inPriceListPriceListType

    OBJECTS st = dataPriceListType
    PROPERTIES(st) READONLY name
    FILTERS inPriceListPriceListType(p, st)

    OBJECTS d = userPriceListDetail
    PROPERTIES(d) isSelectedPriceListDetail, indexUserPriceListDetail, idBarcodeSkuUserPriceListDetail, nameSkuUserPriceListDetail,
                  shortNameUOMSkuUserPriceListDetail, ADDOBJ, delete

    TREE stockTree a=STRING[3], sg = stockGroup PARENT parentStockGroup
    PROPERTIES READONLY OBJVALUE(a), sgTreeName = name(sg)
    ORDER BY sgTreeName
    FILTERS stringEqualsAll(a)
    PROPERTIES(p) inPriceList TODRAW a FORCE GRID
    PROPERTIES(p, sg) inPriceListStockGroupOver

    OBJECTS ts = stock
    PROPERTIES READONLY name(ts), stockName = name(ts) FORCE PANEL
    PROPERTIES(p, ts) inPriceListStockOver

    PROPERTIES(p, t, ts) changeMarkUpSkuUserPriceList TODRAW d FORCE PANEL DRAWTOTOOLBAR

    PROPERTIES(d, st, ts) currentPricePriceListDetailDataPriceListTypeStock COLUMNS (st) HEADER extendNameDataPriceListType(st) TODRAW d FORCE GRID
    PROPERTIES(d, st, ts) markUpPricePriceListDetailDataPriceListTypeStock COLUMNS (st) HEADER extendNameMarkUpDataPriceListType(st) TODRAW d FORCE GRID
    PROPERTIES(d, st) pricePriceListDetailDataPriceListType COLUMNS (st) HEADER name(st)
    PROPERTIES(d, st, ts) currentPricePriceListDetailDataPriceListTypeStock COLUMNS (st) HEADER extendNameDataPriceListType(st)
    PROPERTIES(d, st, ts) markUpPricePriceListDetailDataPriceListTypeStock COLUMNS (st) HEADER extendNameMarkUpDataPriceListType(st)

    FILTERS userPriceListUserPriceListDetail(d) == p,
            isParentSkuGroupSku(sk, skuPriceListDetail(d)) OR (sk IS skuGroup AND d IS priceListDetail AND NOT skuPriceListDetail(d)),
            inStockGroupStock(sg, ts),
            currencyUserPriceList(p) == currencyDataPriceListType(t)

    FILTERGROUP filters
            FILTER 'Выбранные склады' 'F10' inPriceListStockOver(p, ts) DEFAULT

    TREE skuTree2 sk2 = skuGroup PARENT parentSkuGroup
    PROPERTIES READONLY skuTreeName2 = name(sk2)
    ORDER BY skuTreeName2

    OBJECTS ts2 = stock FIXED PANEL
    PROPERTIES(ts2) SELECTOR name
    FILTERS inPriceListStockOver(p, ts2)

    OBJECTS s2=sku
    PROPERTIES inSkuUserPriceList(s2, p) ON CHANGE EXEC changeInSkuUserPriceList(s2, p)
    PROPERTIES READONLY inputName2 = nameSku(s2), idBarcodeSku(s2), currentBalanceSkuStock(s2, ts2)
    PROPERTIES READONLY currentPriceSkuPriceListDataPriceListTypeStock(s2, p, t, ts2) COLUMNS (t) HEADER extendNameDataPriceListType(t)
    FILTERGROUP filters
        FILTER 'С действующей ценой' 'F10' currentPriceSkuPriceListDataPriceListTypeStock(s2, p, t, ts2) DEFAULT

    FILTERGROUP filters2
        FILTER 'С остатком' 'F11' currentBalanceSkuStock(s2, ts2)

    FILTERS isParentSkuGroupSku(sk2, s2)
    ORDER BY inputName2

    EVENTS
        ON OK EXEC prePostUserPriceList(p)

    EDIT userPriceList OBJECT p
;

DESIGN userPriceList FROM DEFAULT {
    REMOVE st.box;
    NEW topContainer{
        NEW headContainer {
            caption = 'Шапка документа';
            childConstraints = TO THE RIGHT;
            ADD PROPERTY (objectClassName);
            ADD PROPERTY (nameNumeratorObject);
            ADD PROPERTY (numberObject);
            ADD PROPERTY (seriesObject);
            ADD PROPERTY (dateUserPriceList);
            ADD PROPERTY (timeUserPriceList);

        }
        NEW timeContainer{
            caption = 'Период действия';
            childConstraints = TO THE RIGHT;
            ADD PROPERTY (fromDateUserPriceList);
            ADD PROPERTY (fromTimeUserPriceList);
            ADD PROPERTY (toDateUserPriceList);
            ADD PROPERTY (toTimeUserPriceList);
        }
        NEW propContainer{
            caption = 'Параметры документа';
            childConstraints = TO THE RIGHT;
            ADD PROPERTY(nameCurrencyUserPriceList);
            ADD PROPERTY(noteUserPriceList);
        }
        POSITION propContainer TO THE RIGHT timeContainer;
        NEW detailContainer{
            childConstraints = TO THE RIGHT;
            type = TABBED;
            NEW firstContainer{
                caption = 'Параметры';
                type = SPLITH;
                NEW firstSecondContainer{
                    type = SPLITV;
                    ADD t.box;
                    ADD stockTree.tree.box{caption = 'Группы складов';}
                }
                ADD ts.box{fillHorizontal = 2.0;}
            }
            NEW secondContainer {
                caption = 'Спецификация';
                childConstraints = TO THE BOTTOM;

                ADD PROPERTY(stockName);
                NEW secondSecondContainer{
                    type = SPLITH;
                    childConstraints =  TO THE RIGHT;
                    ADD skuTree.tree.box {caption = 'Товары';}
                    ADD d.box{fillHorizontal = 3.0;}
                }
            }
            NEW thirdContainer{
                caption = 'Подбор';
                ADD ts2.box;
                NEW detailThirdContainer{
                    childConstraints = TO THE RIGHT;
                    type = SPLITH;
                    ADD skuTree2.tree.box;
                    ADD s2.box{fillHorizontal = 3.0;}
                }
           }
        }
        PROPERTY(formOkAction) {
            caption = 'Провести';
        }
    }

    ADD functions.box;
}

copyUserPriceList 'Копировать' = ACTION (price) NEWSESSION {

    FOR ADDOBJ u = userPriceList DO {
        SET currencyUserPriceList(u) <- currencyUserPriceList(price);
        SET inUserPriceListStock(u, stock) <- inUserPriceListStock(price, stock);
        SET inUserPriceListStockGroup(u, stockGroup) <- inUserPriceListStockGroup(price, stockGroup);
        SET inUserPriceList(u) <- inUserPriceList(price);
        SET inUserPriceListPriceListType(u, priceListType) <- inUserPriceListPriceListType(price, priceListType);
        FOR userPriceListUserPriceListDetail(detail) == price DO {
            FOR ADDOBJ d = userPriceListDetail DO {
                SET userPriceListUserPriceListDetail(d) <- u;
                SET skuUserPriceListDetail(d) <- skuUserPriceListDetail(detail);
            }
        }
        FORM userPriceList OBJECTS p = u MANAGESESSION DOCKED_MODAL;
    }
}

FORM userPriceLists 'Прайсы'

    OBJECTS p = userPriceList
    PROPERTIES(p) READONLY objectClassName, numberObject, seriesObject,
                           fromDateTimeUserPriceList, toDateTimeUserPriceList, nameCurrencyUserPriceList,
                           noteUserPriceList, priceListTypesPriceList, stocksPriceList
    PROPERTIES(p) copyUserPriceList TODRAW p FORCE PANEL DRAWTOTOOLBAR
    PROPERTIES(p) ADDFORM, EDITFORM, delete TODRAW p FORCE PANEL DRAWTOTOOLBAR

    OBJECTS t = dataPriceListType

    OBJECTS d =userPriceListDetail
    PROPERTIES(d) READONLY indexUserPriceListDetail, idBarcodeSkuUserPriceListDetail, nameSkuUserPriceListDetail,
                           shortNameUOMSkuUserPriceListDetail

    OBJECTS ts = stock
    PROPERTIES(ts) READONLY name
    PROPERTIES(p, ts) READONLY inPriceListStockOver

    PROPERTIES(d, t) READONLY pricePriceListDetailDataPriceListType COLUMNS (t) HEADER name(t)

    FILTERS userPriceListUserPriceListDetail(d) == p,
            inPriceListPriceListType(p, t),
            inPriceListStockOver(p, ts),
            currencyUserPriceList(p) == currencyDataPriceListType(t)

;

DESIGN userPriceLists FROM DEFAULT{

    REMOVE t.box;
    NEW topContainer{
        type = SPLITV;
        ADD p.box{fillVertical = 3.0;}
        NEW detailContainer{
            childConstraints = TO THE RIGHT;
            type = SPLITH;
            fillVertical = 2.0;
            NEW firstContainer{
                childConstraints = TO THE RIGHT;
                type = SPLITH;
                ADD d.box{fillHorizontal = 4.0;}
                ADD ts.box{fillHorizontal = 1.0;}
            }
        }
    }
    ADD functions.box;
}

// ------- Проведение по priceListLedger ----- //

EXTEND CLASS priceListDetail : priceListLedger;

fromDateTimePriceListLedger (ledger) += fromDateTimePriceListDetail(ledger);
toDateTimePriceListLedger (ledger) += toDateTimePriceListDetail(ledger);

skuPriceListLedger (ledger) += skuPriceListDetail(ledger);

descriptionPriceListLedger (ledger) += descriptionPriceList(priceListPriceListDetail(ledger));

pricePriceListLedgerLedgerPriceListType (ledger, type) += pricePriceListDetailDataPriceListType(ledger, type);
inPriceListLedgerStock (ledger, stock) += inPriceListStockOver(priceListPriceListDetail(ledger), stock);

// --------------------------- Расчетные виды цен ------------------------- //

CLASS calcPriceListType 'Расчетный вид цены' : priceListType;

basePriceListTypeCalcPriceListType(type) = DATA basePriceListType (calcPriceListType);
nameBasePriceListTypeCalcPriceListType 'Базовый вид цены' (type) = name(basePriceListTypeCalcPriceListType(type));

includeVATCalcPriceListType 'Цена с НДС' = DATA BOOLEAN (calcPriceListType);

includeVATPriceListType(type) += includeVATCalcPriceListType(type);

@defineDocumentHeaderCurrency(calcPriceListType);
currencyPriceListType(calcPriceListType) += currencyCalcPriceListType(calcPriceListType);

TABLE calcPriceListTypePriceGroup (calcPriceListType, priceGroup);

markupCalcPriceListTypePriceGroup 'Надбавка, %' = DATA NUMERIC[8,2] (calcPriceListType, priceGroup);
roundCalcPriceListType 'Округление (кол-во знаков)' = DATA INTEGER (calcPriceListType);

levelParentMarkupPriceGroup (calcPriceListType, priceGroup) = GROUP MIN levelPriceGroupPriceGroup(priceGroup, parent) IF markupCalcPriceListTypePriceGroup(calcPriceListType, parent)
                                                              BY calcPriceListType, priceGroup PERSISTENT;
nearestParentPriceGroup (calcPriceListType, priceGroup) = priceGroupPriceGroupLevel(priceGroup, levelParentMarkupPriceGroup(calcPriceListType, priceGroup));
nearestMarkupCalcPriceListTypePriceGroup 'Расчетная надбавка, %' (calcPriceListType, priceGroup) =
    markupCalcPriceListTypePriceGroup(calcPriceListType, nearestParentPriceGroup(calcPriceListType, priceGroup));

markupCalcPriceListTypePriceGroupOver 'Надбавка, %' (calcPriceListType, priceGroup) =
    UNION OVERRIDE nearestMarkupCalcPriceListTypePriceGroup(calcPriceListType, priceGroup), markupCalcPriceListTypePriceGroup(calcPriceListType, priceGroup);

multiplierCalcPriceListTypePriceGroup (type, priceGroup) = (100 + markupCalcPriceListTypePriceGroupOver(type, priceGroup)) / 100 PERSISTENT;

priceCalcPriceListTypeSkuStockDateTime(type, sku, stock, dateTime) =
    round(priceBasePriceListTypeSkuStockDateTime(basePriceListTypeCalcPriceListType(type), sku, stock, dateTime) * multiplierCalcPriceListTypePriceGroup(type, priceGroupSku(sku)), roundCalcPriceListType(type));
priceCalcPriceListTypeBatchStockDateTime(type, batch, stock, dateTime) =
    round(priceBasePriceListTypeBatchStockDateTime(basePriceListTypeCalcPriceListType(type), batch, stock, dateTime) * multiplierCalcPriceListTypePriceGroup(type, priceGroupSku(skuBatch(batch))), roundCalcPriceListType(type));

pricePriceListTypeSkuStockDateTime(type, sku, stock, dateTime) += priceCalcPriceListTypeSkuStockDateTime(type, sku, stock, dateTime);
pricePriceListTypeBatchStockDateTime(type, batch, stock, dateTime) += priceCalcPriceListTypeBatchStockDateTime(type, batch, stock, dateTime);

backgroundMarkup 'Цвет' (calcPriceListType, priceGroup) = RGB(255,160,160) AND markupCalcPriceListTypePriceGroup(calcPriceListType, priceGroup);

// --------------------------- Формы ------------------------- //

FORM editPriceListType 'Вид цены'
    OBJECTS p = priceListType FIXED PANEL
    PROPERTIES(p) READONLY objectClassName
    PROPERTIES(p) name, includeVATPriceListType

    TREE treeGroup g=priceGroup PARENT parentPriceGroup
    PROPERTIES READONLY name(g)
    ORDER BY name(g)

    EDIT priceListType OBJECT p
;

DESIGN editPriceListType FROM DEFAULT{
    NEW mainContainer{
        childConstraints = TO THE RIGHT;
        type = SPLITH;
        ADD p.box{
            fillHorizontal = 3.0;
            ADD PROPERTY(name);
        }
        ADD treeGroup.tree.box{
            fillHorizontal = 2.0;
        }
    }
    ADD functions.box;
}

EXTEND FORM editPriceListType
    PROPERTIES(p) nameCurrencyDataPriceListType, nameCurrencyCalcPriceListType, nameBasePriceListTypeCalcPriceListType, roundCalcPriceListType
    PROPERTIES(p, g) markupCalcPriceListTypePriceGroup , nearestMarkupCalcPriceListTypePriceGroup
;

EXTEND DESIGN editPriceListType{
    p.box{
        ADD PROPERTY(nameCurrencyDataPriceListType);
        ADD PROPERTY(nameCurrencyCalcPriceListType);
        ADD PROPERTY(nameBasePriceListTypeCalcPriceListType);
        ADD PROPERTY(roundCalcPriceListType);
    }
}

//FORM dataPriceListType 'Базовый вид цен'
//    OBJECTS p = dataPriceListType FIXED PANEL
//    PROPERTIES(p) name, nameCurrencyDataPriceListType

//    EDIT dataPriceListType OBJECT p
//;

//DESIGN dataPriceListType FROM DEFAULT {
//    NEW topContainer{
//       ADD PROPERTY(name);
//        ADD PROPERTY(nameCurrencyDataPriceListType);
//    }
//    ADD functions.box;
//}

//FORM calcPriceListType 'Базовый вид цен'
//    OBJECTS p = calcPriceListType FIXED PANEL
//    PROPERTIES(p) name, nameBasePriceListTypeCalcPriceListType, roundCalcPriceListType

//    TREE treeGroup g=priceGroup PARENT parentPriceGroup
//    PROPERTIES READONLY name(g)
//   ORDER BY name(g)

//    PROPERTIES(p, g) markupCalcPriceListTypePriceGroup , nearestMarkupCalcPriceListTypePriceGroup

//    EDIT calcPriceListType OBJECT p
//;

FORM priceListType 'Вид цены'
    OBJECTS p = priceListType
    PROPERTIES(p) READONLY name, nameCurrencyPriceListType
    PROPERTIES(p) includeVATPriceListType

    DIALOG priceListType OBJECT p
;

FORM priceListTypes 'Виды цен'
    OBJECTS dt = DATETIME FIXED PANEL
    PROPERTIES(dt) objValue = OBJVALUE

    OBJECTS s = stock FIXED PANEL
    PROPERTIES(s) SELECTOR name

    OBJECTS pt = priceListType
    PROPERTIES(pt) READONLY objectClassName, name, nameCurrencyPriceListType
    PROPERTIES(pt) ADDFORM, EDITFORM, delete
    ORDER BY objectClassName

    OBJECTS p = userPriceList
    PROPERTIES(p) READONLY seriesNumberObject, dateUserPriceList, timeUserPriceList, fromDateUserPriceList, fromTimeUserPriceList,
                           toDateUserPriceList, toTimeUserPriceList, nameCurrencyUserPriceList, noteUserPriceList
    PROPERTIES(p) EDITFORM, delete
    ORDER BY fromDateUserPriceList, fromTimeUserPriceList
    FILTERS inPriceListPriceListType(p, pt),
            inPriceListStockOver(p, s)

    TREE skuTree sg = skuGroup PARENT parentSkuGroup
    PROPERTIES READONLY skuTreeName = name(sg)
    ORDER BY skuTreeName

    OBJECTS sk = sku
    PROPERTIES(sk) READONLY nameSku, idBarcodeSku
    PROPERTIES(sk, s, dt) READONLY balanceASkuStockDateTime
    ORDER BY nameSku
    FILTERS isParentSkuGroupSku(sg, sk)

    TREE skuTree2 sg2 = skuGroup PARENT parentSkuGroup
    PROPERTIES READONLY skuTreeName2 = name(sg2)
    ORDER BY skuTreeName2

    OBJECTS b = batch
    PROPERTIES(b) READONLY isPostedBatch, dateBatch, timeBatch, nameSkuBatch, nameStockBatch, descriptionBatch, costBatch
    PROPERTIES(b, s, dt) READONLY balanceABatchStockDateTime
    ORDER BY dateBatch, timeBatch
    FILTERGROUP filters
        FILTER 'Проведенные партии' 'F10' isPostedBatch(b) DEFAULT
    FILTERS isParentSkuGroupBatch(sg2, b)

    PROPERTIES READONLY pricePriceListTypeSkuStockDateTime(pt, sk, s, dt), descriptionLedgerPriceListTypeSkuStockDateTime(pt, sk, s, dt),
                        pricePriceListTypeBatchStockDateTime(pt, b, s, dt), descriptionLedgerPriceListTypeBatchStockDateTime(pt, b, s, dt)
    FILTERS pricePriceListTypeSkuStockDateTime(pt, sk, s, dt),
            pricePriceListTypeBatchStockDateTime(pt, b, s, dt)
;

DESIGN priceListTypes FROM DEFAULT{
    NEW mainContainer{
        type = SPLITV;
        ADD pt.box;
        NEW firstContainer{
            fillVertical = 2.0;
            ADD s.box;
            NEW tabContainer{
                type = TABBED;
                ADD p.box{
                    caption = 'Прайсы';
                }
                NEW priceContainer{
                    caption = 'Текущие цены';
                    childConstraints = TO THE BOTTOM;
                    ADD dt.box;
                    NEW currentPriceContainer{
                        type = TABBED;
                        NEW skuContainer{
                            caption = 'Товары';
                            childConstraints = TO THE RIGHT;
                            type = SPLITH;
                            ADD skuTree.tree.box;
                            ADD sk.box{fillHorizontal = 2.0;}
                        }
                        NEW batchContainer{
                            caption = 'Партии';
                            childConstraints = TO THE RIGHT;
                            type = SPLITH;
                            ADD skuTree2.tree.box;
                            ADD b.box{fillHorizontal = 2.0;}
                        }
                    }
                }
            }
        }
    }
    ADD functions.box;
}

NAVIGATOR {
    NEW priceListNavigator 'Управление ценами' {
        ADD priceListTypes;
        ADD userPriceLists;
    }
}

// --------------------------------------------------- Макросы по добавлению видов цен в документы ------------------------------------ //

META defineDocumentHeaderPriceListType (object)
    priceListType###object (object) = DATA priceListType (object);
    namePriceListType###object 'Вид цен' (object)= name(priceListType###object(object)) IN documentPrmGroup MINCHARWIDTH 5 PREFCHARWIDTH 10;
END
META defineDocumentAbstractHeaderPriceListType (object)
    priceListType###object (object) = ABSTRACT priceListType (object) PERSISTENT;
    namePriceListType###object 'Вид цен' (object)= name(priceListType###object(object)) IN documentPrmGroup MINCHARWIDTH 5 PREFCHARWIDTH 10;
END
META defineDocumentInterfaceHeaderPriceListType (object)
    @defineDocumentAbstractHeaderPriceListType(object);
    @defineDocumentHeaderPriceListType(user###object);
    priceListType###object (object) += priceListType###user###object(object);
END

META defineDocumentDetailPriceListType (object, detail)
    priceListType###detail (idetail) = priceListType###object(object###detail(idetail)) PERSISTENT;
    namePriceListType###detail 'Вид цен' (idetail) = namePriceListType###object(object###detail(idetail)) IN documentPrmGroup MINCHARWIDTH 5 PREFCHARWIDTH 10;
END
META defineDocumentInterfaceDetailPriceListType(object, detail)
    @defineDocumentDetailPriceListType(object, detail);
    @defineDocumentDetailPriceListType(user###object, user###detail);
END

META defineDocumentPriceListType (object, detail)
    @defineDocumentHeaderPriceListType(object);
    @defineDocumentDetailPriceListType(object, detail);
END
META defineDocumentAbstractPriceListType (object, detail)
    @defineDocumentAbstractHeaderPriceListType(object);
    @defineDocumentDetailPriceListType(object, detail);
END
META defineDocumentInterfacePriceListType (object, detail)
    @defineDocumentInterfaceHeaderPriceListType(object);
    @defineDocumentInterfaceDetailPriceListType(object, detail);
END

META defineDocumentPriceListType (object)
    @defineDocumentPriceListType(object, object##Detail);
END
META defineDocumentAbstractPriceListType (object)
    @defineDocumentAbstractPriceListType(object, object##Detail);
END
META defineDocumentInterfacePriceListType (object)
    @defineDocumentInterfacePriceListType(object, object##Detail);
END


// ------------------------- Макросы по добавлению видов цен в документы (два объекта) --------------------- //
META defineDocumentDoubleObjHeaderPriceListType (object1, object2)  //  object1 - документ
    userPriceListType###object1###object2 (object1, object2) = DATA priceListType (object1, object2);

END
META defineDocumentDoubleObjDetailDataPriceListType (detail)
    dataPriceListType###detail =  DATA priceListType (detail);
END
META defineDocumentDoubleObjPriceListType (object1, object2)
    @defineDocumentDoubleObjHeaderPriceListType(object1, object2);
    @defineDocumentDoubleObjDetailDataPriceListType(object1##Detail);
END

//--

META defineDocumentDetailDataPriceListType (object, detail)
    dataPriceListType###detail =  DATA priceListType (detail);
    priceListType###detail (idetail) = UNION OVERRIDE priceListType###object(object###detail(idetail)), dataPriceListType###detail(idetail) PERSISTENT;
    namePriceListType###detail 'Вид цен' (idetail) = name(priceListType###detail(idetail)) MINCHARWIDTH 10 PREFCHARWIDTH 20;
END

META defineDocumentAbstractDetailDataPriceListType (object, detail)
    dataPriceListType###detail =  ABSTRACT priceListType (detail) PERSISTENT;
    priceListType###detail (idetail) = UNION OVERRIDE priceListType###object(object###detail(idetail)), dataPriceListType###detail(idetail) PERSISTENT;
    namePriceListType###detail 'Вид цен' (idetail) = name(priceListType###detail(idetail)) MINCHARWIDTH 10 PREFCHARWIDTH 20;
END

META defineDocumentDataPriceListType (object, detail)
    @defineDocumentHeaderPriceListType(object);
    @defineDocumentDetailDataPriceListType(object, detail);
END
META defineDocumentDataPriceListType (object)
    @defineDocumentDataPriceListType(object, object##Detail);
END

META defineDocumentInterfaceDetailDataPriceListType (object, detail)
    @defineDocumentAbstractDetailDataPriceListType(object, detail);
    @defineDocumentDetailDataPriceListType(user###object, user###detail);
    dataPriceListType###detail (detail) += dataPriceListType###user###detail (detail);
END

META defineDocumentInterfaceDetailDataPriceListType (object)
    @defineDocumentInterfaceDetailDataPriceListType(object, object##Detail);
END

META defineDocumentInterfaceDataPriceListType (object, detail)
    @defineDocumentInterfaceHeaderPriceListType(object);
    @defineDocumentInterfaceDetailDataPriceListType(object, detail);

    CONSTRAINT currency###user###object(object) != currencyPriceListType(priceListType###user###object(object))
               CHECKED BY priceListType###user###object
               MESSAGE 'Валюта документа должны совпадать с валютой вида цены';

    CONSTRAINT currency###user###object(object) != currencyPriceListType(priceListType###user###detail(detail))
               CHECKED BY priceListType###user###detail
               MESSAGE 'Валюта документа должны совпадать с валютой вида цены';
END
META defineDocumentInterfaceDataPriceListType (object)
    @defineDocumentInterfaceDataPriceListType(object, object##Detail);
END

// ----------------------------------------------- Автоматическое проставление

META deriveDocumentDetailPricePriceListTypeCustom (detail, stockProp)
    price###detail(detail) <- prevPricePriceListTypeSkuStockDateTime(priceListType###detail(detail),
                                                                     sku###detail(detail),
                                                                     stockProp###detail(detail),
                                                                     dateTime###detail(detail))
                                    WHEN CHANGED(priceListType###detail(detail)) OR
                                         CHANGED(sku###detail(detail)) OR
                                         CHANGED(stockProp###detail(detail)) OR
                                         CHANGED(dateTime###detail(detail));
END

META deriveDocumentDetailPricePriceListType (object, stockProp)
    @deriveDocumentDetailPricePriceListTypeCustom(object##Detail, stockProp);
END

META deriveDocumentDetailPriceBatchPriceListTypeCustom (detail, stockProp)
    price###detail(detail) <- IF batch###detail(detail) THEN
                                    prevPricePriceListTypeBatchStockDateTime(priceListType###detail(detail),
                                                                             batch###detail(detail),
                                                                             stockProp###detail(detail),
                                                                             dateTime###detail(detail))
                              ELSE
                                    prevPricePriceListTypeSkuStockDateTime(priceListType###detail(detail),
                                                                           sku###detail(detail),
                                                                           stockProp###detail(detail),
                                                                           dateTime###detail(detail))
                                    WHEN CHANGED(batch###detail(detail)) OR
                                         CHANGED(priceListType###detail(detail)) OR
                                         CHANGED(sku###detail(detail)) OR
                                         CHANGED(stockProp###detail(detail)) OR
                                         CHANGED(dateTime###detail(detail));
END

META deriveDocumentDetailPriceBatchPriceListType (object, stockProp)
    @deriveDocumentDetailPriceBatchPriceListTypeCustom(object##Detail, stockProp);
END

META deriveDocumentDetailPriceSystemLedgerPriceListType (concrete, priceListTypeProp, prefixP, skuProp, stockProp)
    prefixP###Price###concrete##Detail (detail)  <- prevPricePriceListTypeSkuStockDateTime(systemLedgerPriceListType.##priceListTypeProp,
                                                                                           skuProp###concrete##Detail(detail),
                                                                                           stockProp###concrete##Detail(detail),
                                                                                           dateTime###concrete##Detail(detail))
                                                    WHEN CHANGED(skuProp###concrete##Detail(detail)) OR
                                                         CHANGED(stockProp###concrete##Detail(detail)) OR
                                                         CHANGED(dateTime###concrete##Detail(detail));
END