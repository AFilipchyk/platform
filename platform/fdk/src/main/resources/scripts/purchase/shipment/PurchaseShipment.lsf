MODULE PurchaseShipment;

REQUIRE Shipment, PurchaseInvoice, PurchaseOperation;

NAMESPACE Purchase;

//----------------------------------------------- Поставка ---------------------------------------------------//

@defineShipment(' (закупка)', customerStock, showPurchasePack, 'Отображать упаковку', purchasePack);
@defineShipmentBatch(customerStock);

@defineShipmentStockDestination(supplierStock, customerStock);

overShipmentPriceUserInvoiceDetail = ABSTRACT NUMERIC[14,2] (userInvoiceDetail) PERSISTENT;
calcShipmentPriceUserInvoiceDetail (detail) = costPriceUserInvoiceDetail(detail) OR overShipmentPriceUserInvoiceDetail(detail) PERSISTENT;

extraShipmentPriceUserInvoiceDetail = ABSTRACT NUMERIC[14,2] (userInvoiceDetail) PERSISTENT;

// Цены учетные
priceUserShipmentDetail (detail) <- costPriceInvoiceDetail(invoiceDetailUserShipmentDetail(detail))
    WHEN CHANGED(priceInvoiceDetail(invoiceDetailUserShipmentDetail(detail)));
shipmentPriceUserInvoiceDetail(detail) <- calcShipmentPriceUserInvoiceDetail(detail) (+) extraShipmentPriceUserInvoiceDetail(detail) WHEN
    (CHANGED(calcShipmentPriceUserInvoiceDetail(detail)) OR
     CHANGED(extraShipmentPriceUserInvoiceDetail(detail)) OR
     CHANGED(createShipmentUserInvoiceDetail(detail)))
        AND createShipmentUserInvoiceDetail(detail);

// Проводим по регистру

overCreateBatchShipmentDetail = ABSTRACT BOOLEAN (shipmentDetail);
createBatchShipmentDetail (detail) = (detail IS shipmentDetail OR overCreateBatchShipmentDetail(detail)) AND NOT batchShipmentDetail(detail);

// Создаем партию
CLASS shipmentBatch 'Партия на основе закупки';
@defineAggregation(shipmentDetail, shipmentBatch, createBatchShipmentDetail);

@defineSkuLedgerAggregation(shipmentDetail, shipmentBatch, sku, customerStock);
priceShipmentBatch (batch) = priceShipmentDetail(shipmentDetailShipmentBatch(batch));

@implementBatch(shipmentBatch, sku, stock, price);
quantityBatch (ledger) += quantityShipmentDetail(shipmentDetailShipmentBatch(ledger));
sumInSkuLedger (ledger) += sumShipmentDetail(shipmentDetailShipmentBatch(ledger));

ledgerBatchShipmentDetail (detail) = shipmentBatchShipmentDetail(detail) OR batchShipmentDetail(detail) PERSISTENT;

batchPriceListLedger(ledger) += ledgerBatchShipmentDetail(invoiceShipmentDetailInvoiceDetail(ledger)) OR batchInvoiceDetail(ledger);
batchPriceListLedger(ledger) += ledgerBatchShipmentDetail(invoiceShipmentDetailInvoiceDetail(invoiceDetailInvoicePriceListLedger(ledger))) OR batchInvoiceDetail(invoiceDetailInvoicePriceListLedger(ledger));

// Проводим по регистру учетных цен
@implementSystemLedgerPriceListTypeBatch(account, shipmentBatch, stock);

// Создаем просто inLIFOSkuLedger
createSkuLedgerShipmentDetail (detail) = detail IS shipmentDetail AND NOT createBatchShipmentDetail(detail);

CLASS shipmentSkuLedger 'Изменение остатка на основе закупки';
@defineAggregation(shipmentDetail, shipmentSkuLedger, createSkuLedgerShipmentDetail);

@defineSkuLedgerAggregation(shipmentDetail, shipmentSkuLedger, sku, customerStock);
priceShipmentSkuLedger (ledger) = priceShipmentDetail(shipmentDetailShipmentSkuLedger(ledger));

@implementSkuLedgerInLIFO(shipmentSkuLedger, sku, stock);
quantityInLIFOSkuLedger (ledger) += quantityShipmentDetail(shipmentDetailShipmentSkuLedger(ledger));
limitInLIFOSkuLedgerBatch(ledger, batch) += quantityShipmentDetail(shipmentDetailShipmentSkuLedger(ledger)) IF batchShipmentDetail(shipmentDetailShipmentSkuLedger(ledger)) == batch;
changedDataSkuLedger(ledger) += CHANGED(batchShipmentDetail(shipmentDetailShipmentSkuLedger(ledger)));
sumInSkuLedger (ledger) += sumShipmentDetail(shipmentDetailShipmentSkuLedger(ledger));

costShipmentDetailBatch(detail, batch) += IF createBatchShipmentDetail(detail) THEN
                                             costSkuLedgerBatch(shipmentBatchShipmentDetail(detail), batch)
                                          ELSE
                                             costSkuLedgerBatch(shipmentSkuLedgerShipmentDetail(detail), batch);

// Проводим по регистру учетных цен
@implementSystemLedgerPriceListType(account, shipmentSkuLedger, stock);
batchPriceListLedger(ledger) += batchShipmentDetail(shipmentDetailShipmentSkuLedger(ledger));

// Пишем в товарный отчет
@implementStockDocumentLedgerInc(shipment, customerStock);
sumIncStockDocumentLedger (ledger) += sumShipmentDetailShipment(ledger);
sumItemIncStockDocumentLedger (ledger) += sumItemShipmentDetailShipment(ledger);
sumContainerIncStockDocumentLedger (ledger) += sumContainerShipmentDetailShipment(ledger);

CONSTRAINT supplierUserShipment(userShipment) AND NOT isSupplierLegalEntity(supplierUserShipment(userShipment))
    CHECKED BY supplierUserShipment MESSAGE 'Для поставки выбрано в качестве поставщика организация, не являющаяся поставщиком';
CONSTRAINT customerUserShipment(userShipment) AND NOT isCompanyLegalEntity(customerUserShipment(userShipment))
    CHECKED BY customerUserShipment MESSAGE 'Для поставки выбрано в качестве покупателя организация, не являющаяся компанией';

//----------------------------------------------- Операции -----------------------------------------------------//

@defineOperationObject(purchase, shipment, s);
@defineSupplierCustomerConstraintOperationObject(purchase, shipment);

//------------------------------ Создание аггрегированных объектов через операции -----------------------------//

createShipmentPurchaseOperation 'Создавать поставку' = DATA BOOLEAN (purchaseOperation) IN createGroup;
createShipmentUserInvoice(invoice) <- createShipmentPurchaseOperation(purchaseOperationUserInvoice(invoice))
    WHEN CHANGED(purchaseOperationUserInvoice(invoice));

EXTEND FORM purchaseOperation
    PROPERTIES(o) createShipmentPurchaseOperation
;

EXTEND DESIGN purchaseOperation{
    tabContainer{
        NEW aggrContainer{
            caption = 'Создание объектов';
            ADD PROPERTY(createShipmentPurchaseOperation);
        }
    }
}

NAVIGATOR {
    purchasePurchaseNavigator {
        ADD shipments;
    }
}