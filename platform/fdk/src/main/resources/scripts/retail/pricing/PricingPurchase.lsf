MODULE PricingPurchase;

REQUIRE Pricing, PurchaseInvoice, Repricing, PurchaseShipment, PurchaseOperation, GLAccountType;

NAMESPACE Purchase;

//----------------------------------------------- Акт расценки ---------------------------------------------------//

// Объявляем вид цены, автоматически проставляем
@defineDocumentInterfacePriceListType (invoice, priceListType, retail, ' (розничный)');

retailPriceListTypeUserInvoiceDetail(detail) <- retailPriceListTypeUserInvoice(userInvoiceUserInvoiceDetail(detail))
                                                WHEN CHANGED(retailPriceListTypeUserInvoice(userInvoiceUserInvoiceDetail(detail)));

// Округление розничной цен (если указан расчетный вид цены, то от него, иначе от склада)
roundConditionUserInvoiceDetail(userInvoiceDetail) =
    IF roundConditionPriceListType(retailPriceListTypeUserInvoiceDetail(userInvoiceDetail))
        THEN roundConditionPriceListType(retailPriceListTypeUserInvoiceDetail(userInvoiceDetail))
        ELSE roundConditionDepartmentStore(customerStockUserInvoiceDetail(userInvoiceDetail));

@defineInvoicePricingAggregation(invoice, Invoice, ' (закупка)', 'Акт расценки на основе инвойса', 'Проведенный акт расценки на основе инвойса', customerStock, );
@defineInvoicePricingRelation(' (закупка)', customerStock);

// -- Операция
@defineOperationProperty(createPricing, 'Акт расценки', createContainer);
@deriveDocumentOperationProperty(UserInvoice, createPricing);

// Вид цены для расценки
pricingPriceListTypeOperation = DATA PriceListType (Operation);
namePricingPriceListTypeOperation 'Вид цен акт расценки' (operation) = name(pricingPriceListTypeOperation(operation));

EXTEND FORM operation
    PROPERTIES(o) namePricingPriceListTypeOperation
;

EXTEND DESIGN operation {
    createContainer {
        ADD PROPERTY(namePricingPriceListTypeOperation);
    }
}

// Записываем тип цены по умолчанию из операции
retailPriceListTypeUserInvoice (invoice) <- pricingPriceListTypeOperation(operationUserInvoice(invoice))
    WHEN CHANGED(operationUserInvoice(invoice));


// Добавляем вид цены на форму
EXTEND FORM userInvoice
    PROPERTIES(i) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i) nameRetailPriceListTypeUserInvoice
    PROPERTIES(d) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i) nameRetailPriceListTypeUserInvoiceDetail BEFORE retailMarkupUserInvoiceDetail
;
EXTEND DESIGN userInvoice {
    headerCreatePricing {
        ADD PROPERTY(nameRetailPriceListTypeUserInvoice);
    }
}

EXTEND FORM invoices PROPERTIES(d) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i) READONLY nameRetailPriceListTypeInvoiceDetail BEFORE retailMarkupInvoiceDetail;

// расчет надбавок и цены при изменении priceListType
@deriveDocumentDetailPriceOnSessionPriceListType (UserInvoiceDetail, retail, pricing, customerStock, userInvoice);

// Изменяем учетную цену
overShipmentPriceUserInvoiceDetail(detail) += retailPriceUserInvoiceDetail(detail)
    WHEN customerStockUserInvoiceDetail(detail) IS DepartmentStore AND NOT costLedgerDepartmentStore(customerStockUserInvoiceDetail(detail));

// Проставляем НДС розничный, равный НДС входному
retailVATUserInvoiceDetail (detail) <- VATUserInvoiceDetail(detail) WHEN CHANGED(VATUserInvoiceDetail(detail));

//----------------------------------------------- Акт дооценки ---------------------------------------------------//
@defineRepricingAggregation(' (закупка)', customerStock);

@defineOperationProperty(createRepricing, 'Акт дооценки', createContainer);
@deriveDocumentOperationProperty(UserInvoice, createRepricing);

// Копирование документа
overCopyInvoice(s, d) += ACTION (s, d) {
    SET createPricingUserInvoice(d) <- createPricingUserInvoice(s);
    SET pricingCommitteeUserInvoice(d) <- pricingCommitteeUserInvoice(s);
    SET retailPriceListTypeUserInvoice(d) <- retailPriceListTypeUserInvoice(s);
}

