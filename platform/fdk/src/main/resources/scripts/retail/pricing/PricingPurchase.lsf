MODULE PricingPurchase;

REQUIRE Pricing, PurchaseInvoice, Repricing, PurchaseShipment, PurchaseOperation, GLAccountType;

NAMESPACE Purchase;

//----------------------------------------------- Акт расценки ---------------------------------------------------//

// Объявляем вид цены, автоматически проставляем
@defineDocumentInterfaceHeaderPriceListType (invoice, calcPriceListType, calcRetail, ' (надбавка)');
@defineDocumentDetailPriceListTypePrefix (invoice, invoiceDetail, calcPriceListType, calcRetail, ' (надбавка)');
@defineDocumentDetailPriceListTypePrefix (userInvoice, userInvoiceDetail, calcPriceListType, calcRetail, ' (надбавка)');
@defineDocumentInterfaceHeaderPriceListType (invoice, priceListType, calcRetail, ' (управленческий)');
@defineDocumentDetailPriceListTypePrefix (invoice, invoiceDetail, priceListType, calcRetail, ' (управленческий)');
@defineDocumentDetailPriceListTypePrefix (userInvoice, userInvoiceDetail, priceListType, calcRetail, ' (управленческий)');

@defineDocumentInterfaceDetailPriceListType (invoice, priceListType, retail, ' (розничная)');

CONSTRAINT currencyUserInvoice(invoice) != currencyPriceListType(calcRetailCalcPriceListTypeUserInvoice(invoice))
           CHECKED BY calcRetailCalcPriceListTypeUserInvoice
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';
CONSTRAINT currencyUserInvoice(invoice) != currencyPriceListType(calcRetailPriceListTypeUserInvoice(invoice))
           CHECKED BY calcRetailPriceListTypeUserInvoice
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';

CONSTRAINT currencyUserInvoiceDetail(detail) != currencyPriceListType(retailPriceListTypeUserInvoiceDetail(detail))
           CHECKED BY retailPriceListTypeUserInvoiceDetail
           MESSAGE 'Валюта документа должна совпадать с валютой вида цены';

retailPriceListTypeUserInvoiceDetail(detail) <- IF prevPricePriceListTypeSkuStockDateTime(calcRetailPriceListTypeUserInvoiceDetail(detail),
                                                                                          skuUserInvoiceDetail(detail),
                                                                                          customerStockUserInvoiceDetail(detail),
                                                                                          dateTimeUserInvoiceDetail(detail))
                                                    THEN calcRetailPriceListTypeUserInvoiceDetail(detail)
                                                    ELSE calcRetailCalcPriceListTypeUserInvoiceDetail(detail)

                                                WHEN CHANGED(calcRetailPriceListTypeUserInvoiceDetail(detail)) OR
                                                     CHANGED(skuUserInvoiceDetail(detail)) OR
                                                     CHANGED(customerStockUserInvoiceDetail(detail)) OR
                                                     CHANGED(dateTimeUserInvoiceDetail(detail));

// Округление розничной цен (если указан расчетный вид цены, то от него, иначе от склада)
roundConditionUserInvoiceDetail(userInvoiceDetail) =
    IF roundConditionPriceListType(retailPriceListTypeUserInvoiceDetail(userInvoiceDetail))
        THEN roundConditionPriceListType(retailPriceListTypeUserInvoiceDetail(userInvoiceDetail))
        ELSE roundConditionDepartmentStore(customerStockUserInvoiceDetail(userInvoiceDetail));

@defineInvoicePricingAggregation(invoice, Invoice, ' (закупка)', 'Акт расценки на основе инвойса', 'Проведенный акт расценки на основе инвойса', customerStock, );
@defineInvoicePricingRelation(' (закупка)', customerStock);
retailPriceListTypePricingDetail(pricingDetail) += retailPriceListTypeInvoiceDetail(invoiceDetailInvoicePricingDetail(pricingDetail));

// -- Операция
@defineOperationProperty(createPricing, 'Акт расценки', createContainer);
@deriveDocumentOperationProperty(UserInvoice, createPricing);

// Вид цены для расценки
pricingPriceListTypeOperation = DATA PriceListType (Operation);
namePricingPriceListTypeOperation 'Вид цен акт расценки (управленческий)' (operation) = namePriceListType(pricingPriceListTypeOperation(operation));

pricingCalcPriceListTypeOperation = DATA CalcPriceListType (Operation);
namePricingCalcPriceListTypeOperation 'Вид цен акт расценки (надбавка)' (operation) = namePriceListType(pricingCalcPriceListTypeOperation(operation));

EXTEND FORM operation
    PROPERTIES(o) namePricingPriceListTypeOperation, namePricingCalcPriceListTypeOperation
;

EXTEND DESIGN operation {
    createContainer {
        ADD PROPERTY(namePricingPriceListTypeOperation);
        ADD PROPERTY(namePricingCalcPriceListTypeOperation);
    }
}

// Записываем тип цены по умолчанию из операции
calcRetailPriceListTypeUserInvoice (invoice) <- pricingPriceListTypeOperation(operationUserInvoice(invoice))
    WHEN CHANGED(operationUserInvoice(invoice));
calcRetailCalcPriceListTypeUserInvoice (invoice) <- pricingCalcPriceListTypeOperation(operationUserInvoice(invoice))
    WHEN CHANGED(operationUserInvoice(invoice));

// Добавляем вид цены на форму
EXTEND FORM userInvoice
    PROPERTIES(i) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i) nameCalcRetailPriceListTypeUserInvoice,
                  nameCalcRetailCalcPriceListTypeUserInvoice
    PROPERTIES(d) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i) nameRetailPriceListTypeUserInvoiceDetail BEFORE retailMarkupUserInvoiceDetail
;
EXTEND DESIGN userInvoice {
    headerCreatePricing {
        ADD PROPERTY(nameCalcRetailPriceListTypeUserInvoice);
        ADD PROPERTY(nameCalcRetailCalcPriceListTypeUserInvoice);
    }
}

EXTEND FORM invoices PROPERTIES(d) SHOWIF createPricingUserInvoice(i) BACKGROUND backgroundRetailInvoice(i) READONLY nameRetailPriceListTypeInvoiceDetail BEFORE retailMarkupInvoiceDetail;

// расчет надбавок и цены при изменении priceListType
@deriveDocumentDetailPriceOnSessionPriceListType (UserInvoiceDetail, retail, pricing, customerStock, userInvoice);

// Изменяем учетную цену
overShipmentPriceUserInvoiceDetail(detail) += retailPriceUserInvoiceDetail(detail)
    WHEN customerStockUserInvoiceDetail(detail) IS DepartmentStore AND NOT costLedgerDepartmentStore(customerStockUserInvoiceDetail(detail));

// Проставляем НДС розничный, равный НДС входному
retailVATUserInvoiceDetail (detail) <- VATUserInvoiceDetail(detail) WHEN CHANGED(VATUserInvoiceDetail(detail));

//----------------------------------------------- Акт дооценки ---------------------------------------------------//
@defineRepricingAggregation(' (закупка)', customerStock);

@defineOperationProperty(createRepricing, 'Акт дооценки', createContainer);
@deriveDocumentOperationProperty(UserInvoice, createRepricing);

// Копирование документа
overCopyInvoice(s, d) += ACTION (s, d) {
    SET createPricingUserInvoice(d) <- createPricingUserInvoice(s);
    SET pricingCommitteeUserInvoice(d) <- pricingCommitteeUserInvoice(s);
    SET calcRetailPriceListTypeUserInvoice(d) <- calcRetailPriceListTypeUserInvoice(s);
    SET calcRetailCalcPriceListTypeUserInvoice(d) <- calcRetailCalcPriceListTypeUserInvoice(s);
}

